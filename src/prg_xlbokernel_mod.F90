!> Pre-conditioned O(N) calculation of the kernel for XL-BOMD.
!! \ingroup PROGRESS
!! \brief Here are subroutines implementing Niklasson's scheme for 
!!  low-rank, Krylov subspace approximation of the kernel. 
module prg_xlbokernel_mod

  use omp_lib
  use bml
  use prg_normalize_mod
  use prg_densitymatrix_mod
  use prg_timer_mod
  use prg_parallel_mod
  use prg_ewald_mod
  use prg_implicit_fermi_mod 

  implicit none

  private  !Everything is private by default

  integer, parameter :: dp = kind(1.0d0)

  public :: prg_kernel_multirank
  public :: prg_kernel_multirank_latte
  public :: prg_kernel_matrix_multirank
  public :: prg_full_kernel
  public :: prg_full_kernel_latte

contains

subroutine Invert(A,AI,N)

implicit none
integer, parameter                          :: PREC = 8
integer, intent(in)                         :: N
real(PREC),                 intent(in)      :: A(N,N)
real(PREC), intent(out)                     :: AI(N,N)
real(PREC)                                  :: WORK(N+N*N)!, C(N,N)
integer                                     :: LDA, LWORK, M, INFO, IPIV(N)
integer                                     :: I,J,K

external DGETRF
external DGETRI

AI = A
LDA = N
M = N
LWORK = N+N*N

call DGETRF(M, N, AI, LDA, IPIV, INFO)
call DGETRI(N, AI, N, IPIV, WORK, LWORK, INFO)

end subroutine Invert
  
!> Compute low rank approximation of (K0*J)^(-1)*K0*(q[n]-n)(for LATTE)
!! \param KRes The low rank approximation 
!! \param KK0_bml The pre-conditioner K0.
!! \param Res The residual q[n]-n
!! \param FelTol Relative error tolerance for approximation 
!! \param L Number of vectors used. 
!! \param LMAX Maximum nr of vectors to use. 
!! \param NUMRANK Nr of vectors to use. 
!! \param HO_bml, Orthogonalized Hamiltonian matrix. 
!! \param mu The chemical potiential. 
!! \param beta Scaled inverse temperature.
!! \param RXYZ Nuclear coordinates.
!! \param Box Box dimensions. 
!! \param Hubbard_U Hubbard U list. 
!! \param Element_Pointer List to keep track of elements. 
!! \param Nr_atoms The number of atoms. 
!! \param HDIM Hamiltonian matrix dimension. 
!! \param Max_Nr_Neigh Max neighbours for Ewald. 
!! \param Coulomb_acc Coulomb accuracy.
!! \param nebcoul Neighbour lists.
!! \param totnebcoul Number of neighbours list. 
!! \param Hinxlist List to keep track of atomic positions in the Hamiltonian. 
!! \param S_bml The S matrix. 
!! \param Z_bml, The Z matrix. 
!! \param Nocc Occupation. 
!! \param Inv_bml, Inverses generated by prg_implicit_fermi_save_inverse.
!! \param DO_bml, D1_bml, H1_bml, Y_bml, X_bml Auxillary matrices.
!! \param m_rec Number of recursion steps.
!! \param threshold Threshold value for matrix truncation.
!! \param Nr_elem Number of elements in Hubbard list. 
subroutine prg_kernel_multirank_latte(KRes,KK0_bml,Res,FelTol,L,LMAX,NUMRANK,HO_bml,mu,beta,RXYZ,Box,Hubbard_U,Element_Pointer, & 
    Nr_atoms,HDIM,Max_Nr_Neigh,Coulomb_acc,nebcoul,totnebcoul,Hinxlist, &
    S_bml,Z_bml,Nocc,Inv_bml,H1_bml,X_bml,Y_bml,DO_bml,D1_bml,m_rec,threshold,Nr_elem)

!! Res = q[n] - n
!! KK0 is preconditioner
!! KRes rank-L approximation of (K0*J)^(-1)*K0*(q[n]-n) with (K0*J)^(-1) as in Eq. (41) in Ref. [*]

  implicit none
  integer,    intent(in)      :: Nr_atoms, HDIM, Nocc,Max_Nr_Neigh,m_rec,Nr_elem,NUMRANK
  real(dp), parameter       :: ONE = 1.D0, TWO = 2.D0, ZERO = 0.D0
  real(dp), intent(in)      :: Coulomb_acc, FelTol, beta, mu
  real(dp), intent(in)      :: RXYZ(3,Nr_atoms), Box(3,3)
  real(dp), intent(in)      :: Res(Nr_atoms)
  integer,    intent(in)      :: Hinxlist(HDIM),Element_Pointer(Nr_atoms)
  real(dp), intent(in)      :: Hubbard_U(Nr_elem)
  type(bml_matrix_t), intent(inout)  :: HO_bml, S_bml, Z_bml, Inv_bml(m_rec), KK0_bml
  real(dp)                  :: K0Res(Nr_atoms)
  type(bml_matrix_t),intent(inout) :: H1_bml, X_bml,Y_bml,DO_bml,D1_bml
  real(dp), intent(in)      :: threshold
  integer,    intent(in)      :: LMAX
  character(20)             :: bml_type
  integer,    intent(in)      :: totnebcoul(Nr_atoms), nebcoul(4,Max_Nr_Neigh,Nr_atoms)
  real(dp)                  :: Coulomb_Pot_Real(Nr_atoms), Coulomb_Pot(Nr_atoms)
  real(dp)                  :: Coulomb_Pot_Real_I, Coulomb_Pot_k(Nr_atoms),dq_dv(Nr_atoms)
  real(dp)                  :: Coulomb_Pot_Real_dq_v(Nr_atoms), Coulomb_Pot_dq_v(Nr_atoms)
  real(dp)                  :: dq_v(Nr_atoms)
  real(dp), intent(inout)   :: KRes(Nr_atoms)
  integer                     :: I,J,K,It,N,MN
  integer, intent(out)        :: L
  real(dp)                  :: Fel, proj_tmp, start, finish
  real(dp)                  :: vi(Nr_atoms,LMAX), fi(Nr_atoms,LMAX), v(Nr_atoms)
  real(dp)                  :: dr(Nr_Atoms), IdentRes(Nr_atoms)
  real(dp), allocatable     :: O(:,:),M(:,:),row1(:),row2(:),row_NA(:)
  type(bml_matrix_t)          :: KK0T_bml, K0Res_bml, Res_bml, ZT_bml, T_bml

  call timer_prg_init()
  bml_type = bml_get_type(HO_bml)
  N = bml_get_N(HO_bml)
  MN = bml_get_M(HO_bml)
  allocate(row1(HDIM)); allocate(row2(HDIM)); allocate(row_NA(Nr_atoms))
  call bml_zero_matrix('csr',bml_element_real,dp,Nr_atoms,Nr_atoms,KK0T_bml)
  call bml_zero_matrix('csr',bml_element_real,dp,Nr_atoms,Nr_atoms,K0Res_bml)
  call bml_zero_matrix('csr',bml_element_real,dp,Nr_atoms,Nr_atoms,Res_bml)
  call bml_zero_matrix(bml_type,bml_element_real,dp,N,MN,ZT_bml)

  call bml_transpose(Z_bml,ZT_bml)

  ! K0Res = KK0*Res temporary for matrix-vector multiplication
  call bml_set_row(Res_bml,1,Res,threshold)
  call bml_transpose(KK0_bml,KK0T_bml)
  call bml_multiply(Res_bml,KK0T_bml,K0Res_bml,1.0_dp,0.0_dp,threshold)
  call bml_get_row(K0Res_bml,1,row_NA)
  K0Res = row_NA
  dr = K0Res

  I = 0
  Fel = 1.D0  
  do while ((Fel > FelTol).AND.(I < (LMAX)).AND.(I < NUMRANK))   !! Fel = "Error" in Swedish
    I = I + 1
    vi(:,I) = dr/norm2(dr)
    do J = 1,I-1
      vi(:,I) = vi(:,I) - dot_product(vi(:,I),vi(:,J))*vi(:,J)  !! Orthogonalized v_i as in Eq. (42) Ref. [*]
    enddo
    vi(:,I) = vi(:,I)/norm2(vi(:,I))
    v(:) = vi(:,I)  ! v_i

    ! Compute H1 = H(v) 
    dq_v = v 
    call prg_timer_start(1)
    !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(J,Coulomb_Pot_Real_I)
    do J = 1,Nr_atoms
      call Ewald_Real_Space_latte(Coulomb_Pot_Real_I,J,RXYZ,Box, &
      dq_v,Hubbard_U,Element_Pointer,Nr_atoms,Coulomb_acc,nebcoul,totnebcoul,HDIM,Max_Nr_Neigh,Nr_elem)
      Coulomb_Pot_Real(J) = Coulomb_Pot_Real_I
    enddo
    !$OMP END PARALLEL DO
    
    call Ewald_k_Space_latte(Coulomb_Pot_k,RXYZ,Box,dq_v,Nr_atoms,Coulomb_acc,Max_Nr_Neigh)
    Coulomb_Pot_dq_v = Coulomb_Pot_Real+Coulomb_Pot_k
    call prg_timer_stop(1,1)


    call bml_deallocate(H1_bml)
    call bml_zero_matrix(bml_type,bml_element_real,dp,HDIM,MN,H1_bml)

    !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(It,K)
    do It = 1,Nr_atoms-1
       do K = Hinxlist(It)+1,Hinxlist(It+1)
           row1(K) = Hubbard_U(Element_Pointer(It))*dq_v(It) + Coulomb_Pot_dq_v(It)
       enddo
    enddo
    !$OMP END PARALLEL DO
    do K = Hinxlist(Nr_atoms)+1,HDIM
         row1(K) = Hubbard_U(Element_Pointer(Nr_atoms))*dq_v(Nr_atoms) + Coulomb_Pot_dq_v(Nr_atoms)
    enddo
     
    ! H1 = 1/2(S*H1+H1*S)
    call bml_set_diagonal(H1_bml,row1,threshold)
    call bml_multiply(S_bml,H1_bml,X_bml,1.0_dp,0.0_dp,threshold) 
    call bml_multiply(H1_bml,S_bml,X_bml,0.5_dp,0.5_dp,threshold)
    call bml_copy(X_bml,H1_bml)

    ! H1 = Z^T H1 Z
    call bml_multiply(ZT_bml,H1_bml,X_bml,1.0_dp,0.0_dp,threshold)
    call bml_multiply(X_bml,Z_bml,H1_bml,1.0_dp,0.0_dp,threshold)

    ! Compute D1 = F_FD(HO_bml + eps*H1_bml)/eps at eps = 0
    call prg_implicit_fermi_first_order_response(HO_bml,H1_bml,DO_bml,D1_bml,Inv_bml, &
        m_rec, mu, beta, real(nocc,dp), threshold)
    
    ! D1 = Z D1 Z^T
    call bml_multiply(Z_bml,D1_bml,Y_bml,2.0_dp,0.0_dp,threshold)
    call bml_multiply(Y_bml,ZT_bml,D1_bml,1.0_dp,0.0_dp,threshold)

    ! Compute dq/dv
    call bml_multiply(D1_bml,S_bml,X_bml, 1.0_dp,0.0_dp,threshold)
    call bml_get_diagonal(X_bml,row1)
    !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(It,K)
    do It = 1, Nr_atoms-1
       dq_dv(It) = 0
       do K = Hinxlist(It)+1,Hinxlist(It+1)
          dq_dv(It) = dq_dv(It) + row1(K)
       enddo
    enddo
    !$OMP END PARALLEL DO
    dq_dv(Nr_atoms) = 0
    do K = Hinxlist(Nr_atoms)+1,HDIM
       dq_dv(Nr_atoms) = dq_dv(Nr_atoms) + row1(K) 
    enddo

    dr = dq_dv - v
    ! fi = K0(dq_dv - v)
    call bml_set_row(Res_bml,1,dr,threshold)
    call bml_multiply(Res_bml,KK0T_bml,K0Res_bml,1.0_dp,0.0_dp,threshold)
    call bml_get_row(K0Res_bml,1,row_NA)
    dr = row_NA
    fi(:,I) = dr

    L = I
    allocate(O(L,L), M(L,L))
    do K = 1,L
    do J = 1,L
       O(K,J) = dot_product(fi(:,K),fi(:,J))  ! O_KJ = < fv_i(K) | fv_i(J) >  see below Eq. (31)
    enddo
    enddo
    call Invert(O,M,L)                        ! M = O^(-1)
    IdentRes = 0.D0*K0Res
    KRes = 0.D0
    do K = 1,L
    do J = 1,L
      proj_tmp = M(K,J)*dot_product(fi(:,J),K0Res)
      IdentRes = IdentRes + proj_tmp*fi(:,K)
      KRes = KRes + proj_tmp*vi(:,K)            !! KRes becomes the rank-L approximate of (K0*J)^(-1)*K0*(q[n]-n) 
    enddo
    enddo
    Fel = norm2(IdentRes-K0Res)/norm2(IdentRes)  !! RELATIVE RESIDUAL ERROR ESTIMATE Eq. (48) Ref. [*]
    write(*,*) '# I, L, Fel = ',I,L,Fel         !! Fel goes down with L
    deallocate(O, M)

  enddo

  deallocate(row1);deallocate(row2);deallocate(row_NA)
  call bml_deallocate(KK0T_bml)
  call bml_deallocate(K0Res_bml)
  call bml_deallocate(Res_bml)
  call bml_deallocate(ZT_bml)
  call prg_timer_shutdown() 

  end subroutine prg_kernel_multirank_latte

  ! Above routine but for development code   
  subroutine prg_kernel_multirank(KRes,KK0_bml,Res,FelTol,L,LMAX,HO_bml,mu,beta,RX,RY,RZ,LBox,Hubbard_U,Element_Type, & 
    Nr_atoms,HDIM,Max_Nr_Neigh,Coulomb_acc,TIMERATIO,nnRx,nnRy,nnRz,nrnnlist,nnType,H_INDEX_START,H_INDEX_END, &
    S_bml,Z_bml,Nocc,Znuc,Inv_bml,H1_bml,X_bml,Y_bml,DO_bml,D1_bml,m_rec,threshold)

!! Res = q[n] - n
!! KK0 is preconditioner
!! KRes rank-L approximation of (K0*J)^(-1)*K0*(q[n]-n) with (K0*J)^(-1) as in Eq. (41) in Ref. [*]

  implicit none
  integer,    intent(in)      :: Nr_atoms, HDIM, Nocc,Max_Nr_Neigh,m_rec
  real(dp), parameter       :: ONE = 1.D0, TWO = 2.D0, ZERO = 0.D0
  real(dp), intent(in)      :: Coulomb_acc, TIMERATIO, FelTol, beta, mu
  real(dp), intent(in)      :: RX(Nr_atoms), RY(Nr_atoms), RZ(Nr_atoms), LBox(3)
  real(dp), intent(in)      :: Res(Nr_atoms)
  integer,    intent(in)      :: H_INDEX_START(Nr_atoms), H_INDEX_END(Nr_atoms)
  real(dp), intent(in)      :: Znuc(Nr_atoms), Hubbard_U(Nr_atoms)
  type(bml_matrix_t), intent(in)  :: HO_bml, S_bml, Z_bml, Inv_bml(m_rec), KK0_bml
  real(dp)                  :: K0Res(Nr_atoms)
  type(bml_matrix_t),intent(inout) :: H1_bml, X_bml,Y_bml,DO_bml,D1_bml
  real(dp), intent(in)      :: threshold
  integer,    intent(in)      :: LMAX
  character(10), intent(in)   :: Element_Type(Nr_atoms)
  integer,    intent(in)      :: nrnnlist(Nr_atoms), nnType(Nr_atoms,Max_Nr_Neigh)
  real(dp), intent(in)      :: nnRx(Nr_atoms,Max_Nr_Neigh)
  real(dp), intent(in)      :: nnRy(Nr_atoms,Max_Nr_Neigh), nnRz(Nr_atoms,Max_Nr_Neigh)
  real(dp)                  :: Coulomb_Pot_Real(Nr_atoms), Coulomb_Pot(Nr_atoms)
  real(dp)                  :: Coulomb_Pot_Real_I, Coulomb_Pot_k(Nr_atoms),dq_dv(Nr_atoms)
  real(dp)                  :: Coulomb_Pot_Real_dq_v(Nr_atoms), Coulomb_Pot_dq_v(Nr_atoms)
  real(dp)                  :: Coulomb_Force_Real_I(3),Coulomb_Force_k(3,Nr_atoms)
  real(dp)                  :: dq_v(Nr_atoms)
  real(dp), intent(inout)   :: KRes(Nr_atoms)
  integer                     :: I,J,K,It
  integer, intent(out)        :: L
  real(dp)                  :: Fel, proj_tmp
  real(dp)                  :: vi(Nr_atoms,LMAX), fi(Nr_atoms,LMAX), v(Nr_atoms)
  real(dp)                  :: dr(Nr_Atoms), IdentRes(Nr_atoms)
  real(dp), allocatable     :: O(:,:),M(:,:),row1(:),row2(:),row_NA(:)
  type(bml_matrix_t)          :: KK0T_bml, K0Res_bml, Res_bml

  allocate(row1(HDIM)); allocate(row2(HDIM)); allocate(row_NA(Nr_atoms))
  call bml_zero_matrix("ellpack",bml_element_real,dp,Nr_atoms,Nr_atoms,KK0T_bml)
  call bml_zero_matrix("ellpack",bml_element_real,dp,Nr_atoms,Nr_atoms,K0Res_bml)
  call bml_zero_matrix("ellpack",bml_element_real,dp,Nr_atoms,Nr_atoms,Res_bml)

  ! K0Res = KK0*Res temporary for matrix-vector multiplication
  call bml_transpose(KK0_bml,KK0T_bml) 
  call bml_set_row(Res_bml,1,Res,ONE*1e-14)
  call bml_multiply(Res_bml,KK0T_bml,K0Res_bml,1.0_dp,0.0_dp,ONE*1e-14)
  call bml_get_row(K0Res_bml,1,row_NA)
  K0Res = row_NA
  dr = K0Res

  I = 0
  Fel = 1.D0  
  do while ((Fel > FelTol).AND.(I < (LMAX)))   !! Fel = "Error" in Swedish
    I = I + 1
    vi(:,I) = dr/norm2(dr)
    do J = 1,I-1
      vi(:,I) = vi(:,I) - dot_product(vi(:,I),vi(:,J))*vi(:,J)  !! Orthogonalized v_i as in Eq. (42) Ref. [*]
    enddo
    vi(:,I) = vi(:,I)/norm2(vi(:,I))
    v(:) = vi(:,I)  ! v_i

    dq_v = v 

    !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(J,Coulomb_Pot_Real_I,Coulomb_Force_Real_I)
    do J = 1,Nr_atoms
      call Ewald_Real_Space(Coulomb_Pot_Real_I,Coulomb_Force_Real_I,J,RX,RY,RZ,LBox, &
      dq_v,Hubbard_U,Element_Type,Nr_atoms,Coulomb_acc,TIMERATIO,nnRx,nnRy,nnRz,nrnnlist,nnType,HDIM,Max_Nr_Neigh)
      Coulomb_Pot_Real(J) = Coulomb_Pot_Real_I
    enddo
    !$OMP END PARALLEL DO
    
    call Ewald_k_Space(Coulomb_Pot_k,Coulomb_Force_k,RX,RY,RZ,LBox,dq_v,Nr_atoms,Coulomb_acc,TIMERATIO,Max_Nr_Neigh)
    Coulomb_Pot_dq_v = Coulomb_Pot_Real+Coulomb_Pot_k

    row1 = 0.0_dp
    do J = 1,HDIM
       call bml_set_row(H1_bml,J,row1,threshold)
    enddo

    !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(J,K)
    do J = 1,Nr_atoms
       do K = H_INDEX_START(J),H_INDEX_END(J)
           row1(K) = Hubbard_U(J)*dq_v(J) + Coulomb_Pot_dq_v(J)
       enddo
    enddo
    !$OMP END PARALLEL DO

    call bml_set_diagonal(H1_bml,row1,threshold)
    call bml_multiply(S_bml,H1_bml,D1_bml,1.0_dp,0.0_dp,threshold) 
    call bml_multiply(H1_bml,S_bml,D1_bml,0.5_dp,0.5_dp,threshold)
    call bml_copy(D1_bml,H1_bml)

    call bml_transpose(Z_bml,X_bml)
    call bml_multiply(X_bml,H1_bml,D1_bml,1.0_dp,0.0_dp,threshold)
    call bml_multiply(D1_bml,Z_bml,H1_bml,1.0_dp,0.0_dp,threshold)

    call prg_implicit_fermi_first_order_response(HO_bml,H1_bml,DO_bml,D1_bml,Inv_bml, &
        m_rec, mu, beta, real(nocc,dp), threshold)
    
    call bml_transpose(Z_bml,X_bml)
    call bml_multiply(Z_bml,D1_bml,Y_bml,2.0_dp,0.0_dp,threshold)
    call bml_multiply(Y_bml,X_bml,D1_bml,1.0_dp,0.0_dp,threshold)

    !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(It,K,row1,row2)
    do It = 1, Nr_atoms
      dq_dv(It) = 0
      do K = H_INDEX_START(It), H_INDEX_END(It)
        call bml_get_row(S_bml,K,row1)
        call bml_get_row(D1_bml,K,row2)
        dq_dv(It) = dq_dv(It) + dot_product(row1,row2)
      enddo
    enddo
    !$OMP END PARALLEL DO

    dr = dq_dv - v 
    ! fi = K0(dq_dv - v)
    call bml_set_row(Res_bml,1,dr,threshold)
    call bml_multiply(Res_bml,KK0T_bml,K0Res_bml,1.0_dp,0.0_dp,threshold)
    call bml_get_row(K0Res_bml,1,row_NA)
    dr = row_NA
    fi(:,I) = dr

    L = I
    allocate(O(L,L), M(L,L))
    do K = 1,L
    do J = 1,L
       O(K,J) = dot_product(fi(:,K),fi(:,J))  ! O_KJ = < fv_i(K) | fv_i(J) >  see below Eq. (31)
    enddo
    enddo
    call Invert(O,M,L)                        ! M = O^(-1)
    IdentRes = 0.D0*K0Res
    KRes = 0.D0
    do K = 1,L
    do J = 1,L
      proj_tmp = M(K,J)*dot_product(fi(:,J),K0Res)
      IdentRes = IdentRes + proj_tmp*fi(:,K)
      KRes = KRes + proj_tmp*vi(:,K)            !! KRes becomes the rank-L approximate of (K0*J)^(-1)*K0*(q[n]-n) 
    enddo
    enddo
    Fel = norm2(IdentRes-K0Res)/norm2(IdentRes)  !! RELATIVE RESIDUAL ERROR ESTIMATE Eq. (48) Ref. [*]
    write(*,*) '# I, L, Fel = ',I,L,Fel         !! Fel goes down with L
    deallocate(O, M)

  enddo

  deallocate(row1);deallocate(row2);deallocate(row_NA)
  call bml_deallocate(KK0T_bml)
  call bml_deallocate(K0Res_bml)
  call bml_deallocate(Res_bml)

  end subroutine prg_kernel_multirank

!> Compute full inverse Jacobian of q[n]-n (for LATTE)
!! \param KK The inverse Jacobian.
!! \param DO_bml Orthogonalized density matrix. 
!! \param mu0 The chemical potiential. 
!! \param RXYZ Nuclear coordinates.
!! \param Box Box dimensions. 
!! \param Hubbard_U Hubbard U list. 
!! \param Element_Pointer List to keep track of elements. 
!! \param Nr_atoms The number of atoms. 
!! \param HDIM Hamiltonian matrix dimension. 
!! \param Max_Nr_Neigh Max neighbours for Ewald. 
!! \param Coulomb_acc Coulomb accuracy
!! \param Hinxlist List to keep track of atomic positions in the Hamiltonian. 
!! \param S_bml The S matrix. 
!! \param Z_bml, The Z matrix. 
!! \param Inv_bml, Inverses generated by prg_implicit_fermi_save_inverse.
!! \param HO_bml, Orthogonalized Hamiltonian matrix. 
!! \param D1_bml, H1_bml, Y_bml, X_bml Auxillary matrices.
!! \param Nocc Occupation. 
!! \param m_rec Number of recursion steps.
!! \param threshold Threshold value for matrix truncation.
!! \param beta Scaled inverse temperature.
!! \param Nr_elem Number of elements in Hubbard list. 
subroutine prg_full_kernel_latte(KK,DO_bml,mu0,RXYZ,Box,Hubbard_U, &
Element_Pointer, Nr_atoms,HDIM, Max_Nr_Neigh,Coulomb_acc, & 
Hinxlist,S_bml,Z_bml,Inv_bml,D1_bml,H1_bml,HO_bml,Y_bml,X_bml, &
Nocc,m_rec,threshold,beta,Nr_elem)

use bml

implicit none
integer, parameter             :: PREC = 8, dp = kind(1.0d0)
integer,    intent(in)         :: Nr_atoms, Nr_elem,HDIM, Nocc, Max_Nr_Neigh,m_rec
real(PREC), parameter          :: ONE = 1.D0, TWO = 2.D0, ZERO = 0.D0
real(PREC), parameter          :: kB = 8.61739d-5 ! eV/K, kB = 6.33366256e-6 Ry/K, kB = 3.166811429e-6 Ha/K
real(PREC), intent(in)         :: Coulomb_acc, threshold,beta
real(PREC)                     :: v(Nr_atoms)
real(PREC), intent(in)         :: RXYZ(3,Nr_atoms),Box(3,3)
integer,    intent(in)         :: Hinxlist(HDIM)
real(PREC), intent(in)         :: Hubbard_U(Nr_elem)
type(bml_matrix_t), intent(in)   :: Inv_bml(m_rec)
type(bml_matrix_t), intent(in)   :: S_bml,Z_bml,HO_bml
type(bml_matrix_t),intent(inout) :: H1_bml,DO_bml,D1_bml,Y_bml,X_bml 
real(PREC), intent(inout)      :: mu0
integer,    intent(in)         :: Element_Pointer(Nr_atoms)
real(PREC)                     :: Coulomb_Pot_Real(Nr_atoms), Coulomb_Pot(Nr_atoms)
real(PREC)                     :: Coulomb_Pot_Real_I, Coulomb_Pot_k(Nr_atoms)
real(PREC)                     :: Coulomb_Pot_Real_dq_v(Nr_atoms), Coulomb_Pot_dq_v(Nr_atoms)
real(PREC)                     :: dq_v(Nr_atoms)
real(PREC)                     :: dq_dv(Nr_atoms), err,tol
real(PREC), intent(out)        :: KK(Nr_atoms,Nr_atoms)
integer                        :: I,J,K, ITER, mm,It,N,MN
real(PREC),allocatable         :: row1(:),row2(:),JJ(:,:)     
type(bml_matrix_t)             :: ZT_bml, R_bml, JJI_bml, JJ_bml, tmp_bml
character(20)                  :: bml_type

  bml_type = bml_get_type(HO_bml)
  N = bml_get_N(HO_bml)
  MN = bml_get_M(HO_bml)
  call bml_zero_matrix(bml_type,bml_element_real,dp,N,MN,ZT_bml)
  call bml_transpose(Z_bml,ZT_bml)
  allocate(row1(HDIM)); allocate(row2(HDIM)); allocate(JJ(Nr_atoms,Nr_atoms))
  Coulomb_Pot_dq_v = ZERO
  Coulomb_Pot_k = ZERO
  dq_v = ZERO
  JJ = ZERO
  KK = ZERO
  
  do J = 1,Nr_atoms  
    dq_v(J) = ONE
    !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I,Coulomb_Pot_Real_I)
    do I = 1,Nr_atoms   
        call Ewald_Real_Space_Single_latte(Coulomb_Pot_Real_I,I,RXYZ,Box,Nr_elem, &
        dq_v,J,Hubbard_U,Element_Pointer,Nr_atoms,Coulomb_acc,HDIM,Max_Nr_Neigh)
        Coulomb_Pot_Real(I) = Coulomb_Pot_Real_I
    enddo
    !$OMP END PARALLEL DO
    call Ewald_k_Space_latte(Coulomb_Pot_k,RXYZ,Box,dq_v,Nr_atoms,Coulomb_acc, &
    Max_Nr_Neigh)
    Coulomb_Pot_dq_v = Coulomb_Pot_Real+Coulomb_Pot_k

    call bml_deallocate(H1_bml)
    call bml_zero_matrix(bml_type,bml_element_real,dp,N,MN,H1_bml)

    !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I,K)
    do I = 1,Nr_atoms-1
       do K = Hinxlist(I)+1,Hinxlist(I+1)
           row1(K) = Hubbard_U(Element_Pointer(I))*dq_v(I) + Coulomb_Pot_dq_v(I)
       enddo
    enddo
    !$OMP END PARALLEL DO
    do K = Hinxlist(Nr_atoms)+1,HDIM
         row1(K) = Hubbard_U(Element_Pointer(Nr_atoms))*dq_v(Nr_atoms) + Coulomb_Pot_dq_v(Nr_atoms)
    enddo

    call bml_set_diagonal(H1_bml,row1,threshold)
    call bml_multiply(S_bml,H1_bml,X_bml,1.0_dp,0.0_dp,threshold) 
    call bml_multiply(H1_bml,S_bml,X_bml,0.5_dp,0.5_dp,threshold)
    call bml_copy(X_bml,H1_bml)

    call bml_multiply(ZT_bml,H1_bml,X_bml,1.0_dp,0.0_dp,threshold)
    call bml_multiply(X_bml,Z_bml,H1_bml,1.0_dp,0.0_dp,threshold)

    call prg_implicit_fermi_first_order_response(HO_bml,H1_bml,DO_bml,D1_bml,Inv_bml, &
           m_rec,mu0,beta,real(nocc,PREC),threshold) 

    call bml_multiply(Z_bml,D1_bml,Y_bml,2.0_dp,0.0_dp,threshold)
    call bml_multiply(Y_bml,ZT_bml,D1_bml,1.0_dp,0.0_dp,threshold)

    call bml_multiply(D1_bml,S_bml,X_bml,1.0_dp,0.0_dp,threshold)
    call bml_get_diagonal(X_bml,row1)
    !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(It,K)
    do It = 1, Nr_atoms-1
       dq_dv(It) = 0
       do K = Hinxlist(It)+1,Hinxlist(It+1)
          dq_dv(It) = dq_dv(It) + row1(K)
       enddo
       JJ(It,J) = dq_dv(It)
    enddo
    !$OMP END PARALLEL DO
    dq_dv(Nr_atoms) = 0
    do K = Hinxlist(Nr_atoms)+1,HDIM
       dq_dv(Nr_atoms) = dq_dv(Nr_atoms) + row1(K) 
    enddo
    JJ(Nr_atoms,J) = dq_dv(Nr_atoms)
    dq_v = ZERO
  enddo
  
  do I = 1,Nr_atoms
     JJ(I,I) = JJ(I,I) - ONE
  enddo
  
  call Invert(JJ,KK,Nr_atoms)
  
  deallocate(row1); deallocate(row2); deallocate(JJ)
  call bml_deallocate(ZT_bml)

end subroutine prg_full_kernel_latte

!> Compute full inverse Jacobian of q[n]-n (for development code) 
!! \param KK The inverse Jacobian.
!! \param DO_bml Orthogonalized density matrix. 
!! \param mu0 The chemical potiential. 
!! \param RX,RY,RZ Nuclear coordinates.
!! \param Lbox Box dimensions. 
!! \param Hubbard_U Hubbard U list. 
!! \param Element_Type List to keep track of elements. 
!! \param Nr_atoms The number of atoms. 
!! \param HDIM Hamiltonian matrix dimension. 
!! \param Max_Nr_Neigh Max neighbours for Ewald. 
!! \param Coulomb_acc Coulomb accuracy
!! \param TIMERATIO Parameter for Ewald
!! \param nnRx,nnRy,nnRz Neighbour lists.
!! \param nrnnlist Number of neighbours list.
!! \param nnType Refers to original order of atoms. 
!! \param H_INDEX_START, H_INDEX_END Lists to keep track of atomic positions in the Hamiltonian. 
!! \param S_bml The S matrix. 
!! \param Z_bml, The Z matrix. 
!! \param Inv_bml, Inverses generated by prg_implicit_fermi_save_inverse.
!! \param HO_bml, Orthogonalized Hamiltonian matrix. 
!! \param D1_bml, H1_bml, Y_bml, X_bml Auxillary matrices.
!! \param Nocc Occupation. 
!! \param Znuc List of nuclear charges.
!! \param m_rec Number of recursion steps.
!! \param threshold Threshold value for matrix truncation.
!! \param beta Scaled inverse temperature.
!! \param diagonal Auxillary vector. 

subroutine prg_full_kernel(KK,DO_bml,mu0,RX,RY,RZ,LBox,Hubbard_U,Element_Type, &
Nr_atoms,HDIM, Max_Nr_Neigh,Coulomb_acc,TIMERATIO,nnRx,nnRy,nnRz, & 
nrnnlist,nnType,H_INDEX_START,H_INDEX_END,S_bml,Z_bml,Inv_bml,D1_bml,H1_bml,HO_bml,Y_bml,X_bml, &
Nocc,Znuc,m_rec,threshold,beta,diagonal)

use bml

implicit none
integer, parameter             :: PREC = 8, dp = kind(1.0d0)
integer,    intent(in)         :: Nr_atoms, HDIM, Nocc, Max_Nr_Neigh,m_rec
real(PREC), parameter          :: ONE = 1.D0, TWO = 2.D0, ZERO = 0.D0
real(PREC), parameter          :: kB = 8.61739d-5 ! eV/K, kB = 6.33366256e-6 Ry/K, kB = 3.166811429e-6 Ha/K
real(PREC), intent(in)         :: Coulomb_acc, TIMERATIO,threshold,beta
real(PREC)                     :: v(Nr_atoms)
real(PREC), intent(in)         :: RX(Nr_atoms), RY(Nr_atoms), RZ(Nr_atoms), LBox(3)
integer,    intent(in)         :: H_INDEX_START(Nr_atoms), H_INDEX_END(Nr_atoms)
real(PREC), intent(in)         :: Znuc(Nr_atoms), Hubbard_U(Nr_atoms)
type(bml_matrix_t), intent(in)   :: Inv_bml(m_rec)
type(bml_matrix_t), intent(in)   :: S_bml,Z_bml,HO_bml
type(bml_matrix_t),intent(inout) :: H1_bml,DO_bml,D1_bml,Y_bml,X_bml 
real(PREC), intent(inout)      :: mu0, diagonal(HDIM)
character(10), intent(in)      :: Element_Type(Nr_atoms)
integer,    intent(in)         :: nrnnlist(Nr_atoms), nnType(Nr_atoms,Max_Nr_Neigh)
real(PREC), intent(in)         :: nnRx(Nr_atoms,Max_Nr_Neigh)
real(PREC), intent(in)         :: nnRy(Nr_atoms,Max_Nr_Neigh), nnRz(Nr_atoms,Max_Nr_Neigh)
real(PREC)                     :: Coulomb_Pot_Real(Nr_atoms), Coulomb_Pot(Nr_atoms)
real(PREC)                     :: Coulomb_Pot_Real_I, Coulomb_Pot_k(Nr_atoms)
real(PREC)                     :: Coulomb_Pot_Real_dq_v(Nr_atoms), Coulomb_Pot_dq_v(Nr_atoms)
real(PREC)                     :: Coulomb_Force_Real_I(3),Coulomb_Force_k(3,Nr_atoms)
real(PREC)                     :: dq_v(Nr_atoms)
real(PREC)                     :: dq_dv(Nr_atoms) 
real(PREC), intent(out)        :: KK(Nr_atoms,Nr_atoms)
integer                        :: I,J,K, ITER, mm,It
real(PREC),allocatable         :: row1(:),row2(:),JJ(:,:)        

  allocate(row1(HDIM)); allocate(row2(HDIM)); allocate(JJ(Nr_atoms,Nr_atoms))
  Coulomb_Pot_dq_v = ZERO
  Coulomb_Pot_k = ZERO
  dq_v = ZERO
  JJ = ZERO
  KK = ZERO
  
  do J = 1,Nr_atoms  
    dq_v(J) = ONE
    !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I,Coulomb_Pot_Real_I)
    do I = 1,Nr_atoms   
        call Ewald_Real_Space_Single(Coulomb_Pot_Real_I,Coulomb_Force_Real_I,I,RX,RY,RZ,LBox, &
        dq_v,J,Hubbard_U,Element_Type,Nr_atoms,Coulomb_acc,TIMERATIO,HDIM,Max_Nr_Neigh)
        Coulomb_Pot_Real(I) = Coulomb_Pot_Real_I
    enddo
    !$OMP END PARALLEL DO
    call Ewald_k_Space(Coulomb_Pot_k,Coulomb_Force_k,RX,RY,RZ,LBox,dq_v,Nr_atoms,Coulomb_acc, &
    TIMERATIO,Max_Nr_Neigh)
    Coulomb_Pot_dq_v = Coulomb_Pot_Real+Coulomb_Pot_k

    diagonal = 0.0_dp
    do I = 1,HDIM
       call bml_set_row(H1_bml,I,diagonal,threshold)
    enddo
    
    !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I,K)
    do I = 1,Nr_atoms
       do K = H_INDEX_START(I),H_INDEX_END(I)
           diagonal(K) = Hubbard_U(I)*dq_v(I) + Coulomb_Pot_dq_v(I)
       enddo
    enddo
    !$OMP END PARALLEL DO
    
    call bml_set_diagonal(H1_bml,diagonal,threshold)
    call bml_multiply(S_bml,H1_bml,D1_bml,1.0_dp,0.0_dp,threshold) 
    call bml_multiply(H1_bml,S_bml,D1_bml,0.5_dp,0.5_dp,threshold)
    call bml_copy(D1_bml,H1_bml)

    call bml_transpose(Z_bml,X_bml)
    call bml_multiply(X_bml,H1_bml,D1_bml,1.0_dp,0.0_dp,threshold)
    call bml_multiply(D1_bml,Z_bml,H1_bml,1.0_dp,0.0_dp,threshold)

    call prg_implicit_fermi_first_order_response(HO_bml,H1_bml,DO_bml,D1_bml,Inv_bml, &
           m_rec,mu0,beta,real(nocc,PREC),threshold) 

    call bml_transpose(Z_bml,X_bml)
    call bml_multiply(Z_bml,D1_bml,Y_bml,2.0_dp,0.0_dp,threshold)
    call bml_multiply(Y_bml,X_bml,D1_bml,1.0_dp,0.0_dp,threshold)

    do It = 1, Nr_atoms
       dq_dv(It) = 0
       do K = H_INDEX_START(It), H_INDEX_END(It)
          call bml_get_row(S_bml,K,row1)
          call bml_get_row(D1_bml,K,row2)
          dq_dv(It) = dq_dv(It) + dot_product(row1,row2)
       enddo
       JJ(It,J) = dq_dv(It)
    enddo
    dq_v = ZERO
  enddo

  do I = 1,Nr_atoms
     JJ(I,I) = JJ(I,I) - ONE
  enddo
  call Invert(JJ,KK,Nr_atoms)
  deallocate(row1); deallocate(row2); deallocate(JJ)

end subroutine prg_full_kernel


! Compute the low-rank kernel matrix. (For development code) 
  subroutine prg_kernel_matrix_multirank(KRes,KK0_bml,Res,FelTol,L,LMAX,HO_bml,mu,beta,RX,RY,RZ,LBox,Hubbard_U,Element_Type, & 
    Nr_atoms,HDIM,Max_Nr_Neigh,Coulomb_acc,TIMERATIO,nnRx,nnRy,nnRz,nrnnlist,nnType,H_INDEX_START,H_INDEX_END, &
    S_bml,Z_bml,Nocc,Znuc,Inv_bml,H1_bml,X_bml,Y_bml,DO_bml,D1_bml,m_rec,threshold)

!! Res = q[n] - n
!! KK0 is preconditioner
!! KRes rank-L approximation of (K0*J)^(-1)*K0*(q[n]-n) with (K0*J)^(-1) as in Eq. (41) in Ref. [*]

  implicit none
  integer,    intent(in)      :: Nr_atoms, HDIM, Nocc,Max_Nr_Neigh,m_rec
  real(dp), parameter       :: ONE = 1.D0, TWO = 2.D0, ZERO = 0.D0
  real(dp), intent(in)      :: Coulomb_acc, TIMERATIO, FelTol, beta, mu
  real(dp), intent(in)      :: RX(Nr_atoms), RY(Nr_atoms), RZ(Nr_atoms), LBox(3)
  real(dp), intent(in)      :: Res(Nr_atoms)
  integer,    intent(in)      :: H_INDEX_START(Nr_atoms), H_INDEX_END(Nr_atoms)
  real(dp), intent(in)      :: Znuc(Nr_atoms), Hubbard_U(Nr_atoms)
  type(bml_matrix_t), intent(in)  :: HO_bml, S_bml, Z_bml, Inv_bml(m_rec)
  real(dp)                  :: K0Res(Nr_atoms)
  type(bml_matrix_t),intent(inout) :: H1_bml, X_bml,Y_bml,DO_bml,D1_bml
  type(bml_matrix_t),intent(inout) :: KK0_bml
  real(dp), intent(in)      :: threshold
  integer,    intent(in)      :: LMAX
  character(10), intent(in)   :: Element_Type(Nr_atoms)
  integer,    intent(in)      :: nrnnlist(Nr_atoms), nnType(Nr_atoms,Max_Nr_Neigh)
  real(dp), intent(in)      :: nnRx(Nr_atoms,Max_Nr_Neigh)
  real(dp), intent(in)      :: nnRy(Nr_atoms,Max_Nr_Neigh), nnRz(Nr_atoms,Max_Nr_Neigh)
  real(dp)                  :: Coulomb_Pot_Real(Nr_atoms), Coulomb_Pot(Nr_atoms)
  real(dp)                  :: Coulomb_Pot_Real_I, Coulomb_Pot_k(Nr_atoms),dq_dv(Nr_atoms)
  real(dp)                  :: Coulomb_Pot_Real_dq_v(Nr_atoms), Coulomb_Pot_dq_v(Nr_atoms)
  real(dp)                  :: Coulomb_Force_Real_I(3),Coulomb_Force_k(3,Nr_atoms)
  real(dp)                  :: dq_v(Nr_atoms)
  real(dp), intent(out)     :: KRes(Nr_atoms)
  integer                     :: I,J,K,It,col,row
  integer, intent(out)        :: L
  real(dp)                  :: Fel, proj_tmp,elem
  real(dp)                  :: vi(Nr_atoms,LMAX), fi(Nr_atoms,LMAX), v(Nr_atoms)
  real(dp)                  :: dr(Nr_Atoms), IdentRes(Nr_atoms)
  real(dp), allocatable     :: O(:,:),M(:,:),row1(:),row2(:)

  allocate(row1(HDIM));allocate(row2(HDIM));

  dr = Res
  I = 0
  Fel = 1.D0  
  do while ((Fel > FelTol).AND.(I < (LMAX)))   !! Fel = "Error" in Swedish
    I = I + 1
    vi(:,I) = dr/norm2(dr)
    do J = 1,I-1
      vi(:,I) = vi(:,I) - dot_product(vi(:,I),vi(:,J))*vi(:,J)  !! Orthogonalized v_i as in Eq. (42) Ref. [*]
    enddo
    vi(:,I) = vi(:,I)/norm2(vi(:,I))
    v(:) = vi(:,I)  ! v_i

    dq_v = v 

    !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I,Coulomb_Pot_Real_I,Coulomb_Force_Real_I)
    do J = 1,Nr_atoms
      call Ewald_Real_Space(Coulomb_Pot_Real_I,Coulomb_Force_Real_I,J,RX,RY,RZ,LBox, &
      dq_v,Hubbard_U,Element_Type,Nr_atoms,Coulomb_acc,TIMERATIO,nnRx,nnRy,nnRz,nrnnlist,nnType,HDIM,Max_Nr_Neigh)
      Coulomb_Pot_Real(J) = Coulomb_Pot_Real_I
    enddo
    !$OMP END PARALLEL DO
    
    call Ewald_k_Space(Coulomb_Pot_k,Coulomb_Force_k,RX,RY,RZ,LBox,dq_v,Nr_atoms,Coulomb_acc,TIMERATIO,Max_Nr_Neigh)
    Coulomb_Pot_dq_v = Coulomb_Pot_Real+Coulomb_Pot_k

    row1 = 0.0_dp
    do J = 1,HDIM
       call bml_set_row(H1_bml,J,row1,threshold)
    enddo

    !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(J,K)
    do J = 1,Nr_atoms
       do K = H_INDEX_START(J),H_INDEX_END(J)
           row1(K) = Hubbard_U(J)*dq_v(J) + Coulomb_Pot_dq_v(J)
       enddo
    enddo
    !$OMP END PARALLEL DO

    call bml_set_diagonal(H1_bml,row1,threshold)
    call bml_multiply(S_bml,H1_bml,D1_bml,1.0_dp,0.0_dp,threshold) 
    call bml_multiply(H1_bml,S_bml,D1_bml,0.5_dp,0.5_dp,threshold)
    call bml_copy(D1_bml,H1_bml)

    call bml_transpose(Z_bml,X_bml)
    call bml_multiply(X_bml,H1_bml,D1_bml,1.0_dp,0.0_dp,threshold)
    call bml_multiply(D1_bml,Z_bml,H1_bml,1.0_dp,0.0_dp,threshold)

    call prg_implicit_fermi_first_order_response(HO_bml,H1_bml,DO_bml,D1_bml,Inv_bml, &
        m_rec, mu, beta, real(nocc,dp), threshold)
    
    call bml_transpose(Z_bml,X_bml)
    call bml_multiply(Z_bml,D1_bml,Y_bml,2.0_dp,0.0_dp,threshold)
    call bml_multiply(Y_bml,X_bml,D1_bml,1.0_dp,0.0_dp,threshold)

    !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(It,K,row1,row2)
    do It = 1, Nr_atoms
      dq_dv(It) = 0
      do K = H_INDEX_START(It), H_INDEX_END(It)
        call bml_get_row(S_bml,K,row1)
        call bml_get_row(D1_bml,K,row2)
        dq_dv(It) = dq_dv(It) + dot_product(row1,row2)
      enddo
    enddo
    !$OMP END PARALLEL DO

    dr = dq_dv - v 
    fi(:,I) = dr

    L = I
    allocate(O(L,L), M(L,L))
    do K = 1,L
    do J = 1,L
       O(K,J) = dot_product(fi(:,K),fi(:,J))  ! O_KJ = < fv_i(K) | fv_i(J) >  see below Eq. (31)
    enddo
    enddo
    call Invert(O,M,L)                        ! M = O^(-1)
    IdentRes = 0.D0*Res
    KRes = 0.D0
    do K = 1,L
    do J = 1,L
      proj_tmp = M(K,J)*dot_product(fi(:,J),Res)
      IdentRes = IdentRes + proj_tmp*fi(:,K)
      KRes = KRes + proj_tmp*vi(:,K)            !! KRes becomes the rank-L approximate of (J)^(-1)*(q[n]-n) 
    enddo
    enddo
    Fel = norm2(IdentRes-Res)/norm2(IdentRes)  !! RELATIVE RESIDUAL ERROR ESTIMATE Eq. (48) Ref. [*]
    write(*,*) '# I, L, Fel = ',I,L,Fel         !! Fel goes down with L
  
    ! Does not work, need to normalize matrix  
        if ((Fel > FelTol).AND.(I < (LMAX))) then 
          deallocate(O, M)
        else 
         do row = 1,Nr_atoms
         do col = 1,Nr_atoms 
           elem = 0.0
           do K = 1,L
             do J = 1,L 
               elem = elem + M(J,K)*vi(row,J)*fi(col,K)
             enddo
           enddo 
           if (abs(elem) > threshold) then
             call bml_set_element(KK0_bml,row,col,elem)
           endif
         enddo
         enddo  
         deallocate(O,M)
         endif
    enddo 
    deallocate(row1); deallocate(row2);

  end subroutine prg_kernel_matrix_multirank

end module prg_xlbokernel_mod
