!> Pre-conditioned O(N) calculation of the kernel for XL-BOMD.
!! \ingroup PROGRESS
!! \brief Here are subroutines implementing Niklasson's scheme for
!!  low-rank, Krylov subspace approximation of the kernel.
module prg_xlbokernel_mod

  use omp_lib
  use bml
  use prg_normalize_mod
  use prg_densitymatrix_mod
  use prg_timer_mod
  use prg_parallel_mod
  use prg_ewald_mod
  use prg_implicit_fermi_mod

  implicit none

  private  !Everything is private by default

  integer, parameter :: dp = kind(1.0d0)

  public :: prg_kernel_multirank
  public :: prg_kernel_multirank_latte
  public :: prg_kernel_matrix_multirank
  public :: prg_full_kernel
  public :: prg_full_kernel_latte

contains

  subroutine Invert(A,AI,N)

    implicit none
    integer, parameter                          :: PREC = 8
    integer, intent(in)                         :: N
    real(PREC),                 intent(in)      :: A(N,N)
    real(PREC), intent(out)                     :: AI(N,N)
    real(PREC)                                  :: WORK(N+N*N)!, C(N,N)
    integer                                     :: LDA, LWORK, M, INFO, IPIV(N)
    integer                                     :: I,J,K

    external DGETRF
    external DGETRI

    AI = A
    LDA = N
    M = N
    LWORK = N+N*N

    call DGETRF(M, N, AI, LDA, IPIV, INFO)
    call DGETRI(N, AI, N, IPIV, WORK, LWORK, INFO)

  end subroutine Invert

  !> Compute low rank approximation of (K0*J)^(-1)*K0*(q[n]-n)(for LATTE)
  !! \param KRes The low rank approximation
  !! \param KK0_bml The pre-conditioner K0.
  !! \param Res The residual q[n]-n
  !! \param FelTol Relative error tolerance for approximation
  !! \param L Number of vectors used.
  !! \param LMAX Maximum nr of vectors to use.
  !! \param NUMRANK Nr of vectors to use.
  !! \param HO_bml, Orthogonalized Hamiltonian matrix.
  !! \param mu The chemical potiential.
  !! \param beta Scaled inverse temperature.
  !! \param RXYZ Nuclear coordinates.
  !! \param Box Box dimensions.
  !! \param Hubbard_U Hubbard U list.
  !! \param Element_Pointer List to keep track of elements.
  !! \param Nr_atoms The number of atoms.
  !! \param HDIM Hamiltonian matrix dimension.
  !! \param Max_Nr_Neigh Max neighbours for Ewald.
  !! \param Coulomb_acc Coulomb accuracy.
  !! \param nebcoul Neighbour lists.
  !! \param totnebcoul Number of neighbours list.
  !! \param Hinxlist List to keep track of atomic positions in the Hamiltonian.
  !! \param S_bml The S matrix.
  !! \param Z_bml, The Z matrix.
  !! \param Nocc Occupation.
  !! \param Inv_bml, Inverses generated by prg_implicit_fermi_save_inverse.
  !! \param DO_bml, D1_bml, H1_bml, Y_bml, X_bml Auxillary matrices.
  !! \param m_rec Number of recursion steps.
  !! \param threshold Threshold value for matrix truncation.
  !! \param Nr_elem Number of elements in Hubbard list.
  subroutine prg_kernel_multirank_latte(KRes,KK0_bml,Res,FelTol,L,LMAX,NUMRANK,HO_bml,mu,beta,RXYZ,Box,Hubbard_U,Element_Pointer, &
       Nr_atoms,HDIM,Max_Nr_Neigh,Coulomb_acc,nebcoul,totnebcoul,Hinxlist, &
       S_bml,Z_bml,Nocc,Inv_bml,H1_bml,DO_bml,D1_bml,m_rec,threshold,Nr_elem,mdstep,update)

    !! Res = q[n] - n
    !! KK0 is preconditioner
    !! KRes rank-L approximation of (K0*J)^(-1)*K0*(q[n]-n) with (K0*J)^(-1) as in Eq. (41) in Ref. [*]

    implicit none
    integer,    intent(in)      :: Nr_atoms, HDIM, Max_Nr_Neigh,m_rec,Nr_elem,NUMRANK,mdstep,update
    real(dp), parameter       :: ONE = 1.D0, TWO = 2.D0, ZERO = 0.D0
    real(dp), intent(in)      :: Coulomb_acc, FelTol, beta, mu, Nocc
    real(dp), intent(in)      :: RXYZ(3,Nr_atoms), Box(3,3)
    real(dp), intent(in)      :: Res(Nr_atoms)
    integer,    intent(in)      :: Hinxlist(HDIM),Element_Pointer(Nr_atoms)
    real(dp), intent(in)      :: Hubbard_U(Nr_elem)
    type(bml_matrix_t), intent(inout)  :: HO_bml, S_bml, Z_bml, Inv_bml(m_rec), KK0_bml
    real(dp)                  :: K0Res(Nr_atoms)
    type(bml_matrix_t),intent(inout) :: H1_bml, DO_bml,D1_bml
    real(dp), intent(in)      :: threshold
    integer,    intent(in)      :: LMAX
    character(20)             :: bml_type
    integer,    intent(in)      :: totnebcoul(Nr_atoms), nebcoul(4,Max_Nr_Neigh,Nr_atoms)
    real(dp)                  :: Coulomb_Pot_Real(Nr_atoms), Coulomb_Pot(Nr_atoms)
    real(dp)                  :: Coulomb_Pot_Real_I, Coulomb_Pot_k(Nr_atoms),dq_dv(Nr_atoms)
    real(dp)                  :: Coulomb_Pot_Real_dq_v(Nr_atoms), Coulomb_Pot_dq_v(Nr_atoms)
    real(dp)                  :: dq_v(Nr_atoms)
    real(dp), intent(inout)   :: KRes(Nr_atoms)
    integer                     :: I,J,K,It,N,MN
    integer, intent(out)        :: L
    real(dp)                  :: Fel, proj_tmp, start, finish
    real(dp)                  :: vi(Nr_atoms,LMAX), fi(Nr_atoms,LMAX), v(Nr_atoms)
    real(dp)                  :: dr(Nr_Atoms), IdentRes(Nr_atoms)
    real(dp), allocatable     :: O(:,:),M(:,:),row1(:),row2(:),row_NA(:)
    type(bml_matrix_t)          :: KK0T_bml, K0Res_bml, Res_bml, ZT_bml, T_bml, X_bml, Y_bml

    call timer_prg_init()
    bml_type = bml_get_type(HO_bml)
    N = bml_get_N(HO_bml)
    MN = bml_get_M(HO_bml)
    allocate(row1(HDIM)); allocate(row2(HDIM)); allocate(row_NA(Nr_atoms))
    call bml_zero_matrix(bml_type,bml_element_real,dp,Nr_atoms,Nr_atoms,KK0T_bml)
    call bml_zero_matrix(bml_type,bml_element_real,dp,Nr_atoms,Nr_atoms,K0Res_bml)
    call bml_zero_matrix(bml_type,bml_element_real,dp,Nr_atoms,Nr_atoms,Res_bml)
    call bml_zero_matrix(bml_type,bml_element_real,dp,N,MN,ZT_bml)
    call bml_zero_matrix(bml_type,bml_element_real,dp,N,MN,X_bml)
    call bml_zero_matrix(bml_type,bml_element_real,dp,N,MN,Y_bml)

    call bml_transpose(Z_bml,ZT_bml)

    ! K0Res = KK0*Res temporary for matrix-vector multiplication
    call bml_set_row(Res_bml,1,Res,1.0_dp*1e-10)
    call bml_transpose(KK0_bml,KK0T_bml)
    call bml_multiply(Res_bml,KK0T_bml,K0Res_bml,1.0_dp,0.0_dp,1.0_dp*1e-10)
    call bml_get_row(K0Res_bml,1,row_NA)
    K0Res = row_NA
    dr = K0Res

    write(*,*) 'resnorm =', norm2(Res), 'kresnorm =', norm2(dr)
    I = 0
    Fel = 1.D0
    do while ((Fel > FelTol).AND.(I < (LMAX)).AND.(I < NUMRANK))   !! Fel = "Error" in Swedish
      I = I + 1
      !write(*,*) 'dr =', norm2(dr)
      vi(:,I) = dr/norm2(dr)
      do J = 1,I-1
        vi(:,I) = vi(:,I) - dot_product(vi(:,I),vi(:,J))*vi(:,J)  !! Orthogonalized v_i as in Eq. (42) Ref. [*]
      enddo
      vi(:,I) = vi(:,I)/norm2(vi(:,I))
      v(:) = vi(:,I)  ! v_i

      ! Compute H1 = H(v)
      dq_v = v
      call prg_timer_start(1)
      !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(J,Coulomb_Pot_Real_I)
      do J = 1,Nr_atoms
        call Ewald_Real_Space_latte(Coulomb_Pot_Real_I,J,RXYZ,Box, &
             dq_v,Hubbard_U,Element_Pointer,Nr_atoms,Coulomb_acc,nebcoul,totnebcoul,HDIM,Max_Nr_Neigh,Nr_elem)
        Coulomb_Pot_Real(J) = Coulomb_Pot_Real_I
      enddo
      !$OMP END PARALLEL DO

      call Ewald_k_Space_latte(Coulomb_Pot_k,RXYZ,Box,dq_v,Nr_atoms,Coulomb_acc,Max_Nr_Neigh)
      Coulomb_Pot_dq_v = Coulomb_Pot_Real+Coulomb_Pot_k
      call prg_timer_stop(1,1)


      call bml_deallocate(H1_bml)
      call bml_zero_matrix(bml_type,bml_element_real,dp,HDIM,MN,H1_bml)

      !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(It,K)
      do It = 1,Nr_atoms-1
        do K = Hinxlist(It)+1,Hinxlist(It+1)
          row1(K) = Hubbard_U(Element_Pointer(It))*dq_v(It) + Coulomb_Pot_dq_v(It)
        enddo
      enddo
      !$OMP END PARALLEL DO
      do K = Hinxlist(Nr_atoms)+1,HDIM
        row1(K) = Hubbard_U(Element_Pointer(Nr_atoms))*dq_v(Nr_atoms) + Coulomb_Pot_dq_v(Nr_atoms)
      enddo

      ! H1 = 1/2(S*H1+H1*S)
      call bml_set_diagonal(H1_bml,row1,threshold)
      call bml_multiply(S_bml,H1_bml,X_bml,1.0_dp,0.0_dp,threshold)
      call bml_multiply(H1_bml,S_bml,X_bml,0.5_dp,0.5_dp,threshold)
      call bml_copy(X_bml,H1_bml)

      ! H1 = Z^T H1 Z
      call bml_multiply(ZT_bml,H1_bml,X_bml,1.0_dp,0.0_dp,threshold)
      call bml_multiply(X_bml,Z_bml,H1_bml,1.0_dp,0.0_dp,threshold)

      ! Compute D1 = F_FD(HO_bml + eps*H1_bml)/eps at eps = 0
      call prg_implicit_fermi_first_order_response(HO_bml,H1_bml,DO_bml,D1_bml,Inv_bml, &
           m_rec, mu, beta, real(nocc,dp), threshold)

      ! D1 = Z D1 Z^T
      call bml_multiply(Z_bml,D1_bml,Y_bml,2.0_dp,0.0_dp,threshold)
      call bml_multiply(Y_bml,ZT_bml,D1_bml,1.0_dp,0.0_dp,threshold)

      ! Compute dq/dv
      call bml_multiply(D1_bml,S_bml,X_bml, 1.0_dp,0.0_dp,threshold)
      call bml_get_diagonal(X_bml,row1)
      !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(It,K)
      do It = 1, Nr_atoms-1
        dq_dv(It) = 0
        do K = Hinxlist(It)+1,Hinxlist(It+1)
          dq_dv(It) = dq_dv(It) + row1(K)
        enddo
      enddo
      !$OMP END PARALLEL DO
      dq_dv(Nr_atoms) = 0
      do K = Hinxlist(Nr_atoms)+1,HDIM
        dq_dv(Nr_atoms) = dq_dv(Nr_atoms) + row1(K)
      enddo

      dr = dq_dv - v
      ! fi = K0(dq_dv - v)
      call bml_set_row(Res_bml,1,dr,1.0_dp*1e-10)
      call bml_multiply(Res_bml,KK0T_bml,K0Res_bml,1.0_dp,0.0_dp,1.0_dp*1e-10)
      call bml_get_row(K0Res_bml,1,row_NA)
      dr = row_NA
      fi(:,I) = dr

      L = I
      allocate(O(L,L), M(L,L))
      do K = 1,L
        do J = 1,L
          O(K,J) = dot_product(fi(:,K),fi(:,J))  ! O_KJ = < fv_i(K) | fv_i(J) >  see below Eq. (31)
        enddo
      enddo
      call Invert(O,M,L)                        ! M = O^(-1)
      IdentRes = 0.D0*K0Res
      KRes = 0.D0
      do K = 1,L
        do J = 1,L
          proj_tmp = M(K,J)*dot_product(fi(:,J),K0Res)
          IdentRes = IdentRes + proj_tmp*fi(:,K)
          KRes = KRes + proj_tmp*vi(:,K)            !! KRes becomes the rank-L approximate of (K0*J)^(-1)*K0*(q[n]-n)
        enddo
      enddo
      Fel = norm2(IdentRes-K0Res)/norm2(IdentRes)  !! RELATIVE RESIDUAL ERROR ESTIMATE Eq. (48) Ref. [*]
      write(*,*) '# I, L, Fel = ',I,L,Fel         !! Fel goes down with L
      deallocate(O, M)

    enddo

    if (modulo(mdstep,update) .eq. 0) then
      call prg_update_preconditioner(KK0_bml,vi(:,1),fi(:,1),Nr_atoms,threshold)
    endif

    deallocate(row1);deallocate(row2);deallocate(row_NA)
    call bml_deallocate(KK0T_bml)
    call bml_deallocate(K0Res_bml)
    call bml_deallocate(Res_bml)
    call bml_deallocate(ZT_bml)
    call bml_deallocate(X_bml)
    call bml_deallocate(Y_bml)
    call prg_timer_shutdown()

  end subroutine prg_kernel_multirank_latte

  subroutine prg_update_preconditioner(K0,v,fv,Nr_atoms,threshold)

    implicit none
    type(bml_matrix_t), intent(inout)  :: K0
    real(dp), intent(in)               :: v(Nr_atoms),fv(Nr_atoms),threshold
    integer, intent(in)                :: Nr_atoms
    type(bml_matrix_t)                 :: v_bml,fv_bml,vt_bml,tmp1_bml,tmp2_bml
    type(bml_matrix_t)                 :: ones_bml,onest_bml,K0_update,K0_T
    real(dp)                           :: const,kthresh
    real(dp)                           :: ones(Nr_atoms)
    real(dp),allocatable               :: row(:),norm(:)
    integer                            :: I
    character(20)                      :: bml_type

    bml_type = bml_get_type(K0)
    kthresh = 1.0_dp*1e-5
    allocate(row(Nr_atoms))
    allocate(norm(Nr_atoms))

    call bml_zero_matrix(bml_type,bml_element_real,dp,Nr_atoms,Nr_atoms,v_bml)
    call bml_zero_matrix(bml_type,bml_element_real,dp,Nr_atoms,Nr_atoms,vt_bml)
    call bml_zero_matrix(bml_type,bml_element_real,dp,Nr_atoms,Nr_atoms,fv_bml)
    call bml_zero_matrix(bml_type,bml_element_real,dp,Nr_atoms,Nr_atoms,tmp1_bml)
    call bml_zero_matrix(bml_type,bml_element_real,dp,Nr_atoms,Nr_atoms,tmp2_bml)
    call bml_zero_matrix(bml_type,bml_element_real,dp,Nr_atoms,Nr_atoms,ones_bml)
    call bml_zero_matrix(bml_type,bml_element_real,dp,Nr_atoms,Nr_atoms,onest_bml)
    call bml_zero_matrix(bml_type,bml_element_real,dp,Nr_atoms,Nr_atoms,K0_update)
    call bml_zero_matrix(bml_type,bml_element_real,dp,Nr_atoms,Nr_atoms,K0_T)

    ones = 1.0_dp
    call bml_set_row(onest_bml,1,ones,0.0_dp)
    call bml_multiply(K0,ones_bml,tmp1_bml,1.0_dp,0.0_dp,threshold)
    const = 1.0_dp/(bml_trace_mult(onest_bml,tmp1_bml) + 1)

    call bml_set_row(vt_bml,1,v,1.0_dp*1e-10)
    call bml_set_row(fv_bml,1,fv,1.0_dp*1e-10)
    call bml_transpose(vt_bml,v_bml)

    call bml_multiply(K0,v_bml,tmp1_bml,1.0_dp,0.0_dp,threshold)
    call bml_copy(vt_bml,tmp2_bml)
    call bml_multiply(fv_bml,K0,tmp2_bml,1.0_dp,-1.0_dp,threshold)
    call bml_multiply(tmp1_bml,tmp2_bml,K0_update,const,0.0_dp,kthresh)
    call bml_add(K0,K0_update,1.0_dp,-1.0_dp,kthresh)

    call bml_multiply(onest_bml,K0,tmp1_bml,1.0_dp,0.0_dp,0.0_dp)
    call bml_get_row(tmp1_bml,1,norm)
    call bml_transpose(K0,K0_T)
    do I = 1,Nr_atoms
      call bml_get_row(K0_T,1,row)
      call bml_set_row(K0_T,1,row/norm(I),1.0_dp*1e-10)
    enddo
    call bml_transpose(K0_T,K0)

    deallocate(row)
    deallocate(norm)
    call bml_deallocate(v_bml)
    call bml_deallocate(vt_bml)
    call bml_deallocate(fv_bml)
    call bml_deallocate(tmp1_bml)
    call bml_deallocate(tmp2_bml)
    call bml_deallocate(onest_bml)
    call bml_deallocate(ones_bml)
    call bml_deallocate(K0_update)
    call bml_deallocate(K0_T)

  end subroutine prg_update_preconditioner


  ! Above routine but for development code
  subroutine prg_kernel_multirank(KRes,KK0_bml,Res,FelTol,L,LMAX,HO_bml,mu,beta,RX,RY,RZ,LBox,Hubbard_U,Element_Type, &
       Nr_atoms,HDIM,Max_Nr_Neigh,Coulomb_acc,TIMERATIO,nnRx,nnRy,nnRz,nrnnlist,nnType,H_INDEX_START,H_INDEX_END, &
       S_bml,Z_bml,Nocc,Znuc,Inv_bml,H1_bml,X_bml,Y_bml,DO_bml,D1_bml,m_rec,threshold)

    !! Res = q[n] - n
    !! KK0 is preconditioner
    !! KRes rank-L approximation of (K0*J)^(-1)*K0*(q[n]-n) with (K0*J)^(-1) as in Eq. (41) in Ref. [*]

    implicit none
    integer,    intent(in)      :: Nr_atoms, HDIM, Nocc,Max_Nr_Neigh,m_rec
    real(dp), parameter       :: ONE = 1.D0, TWO = 2.D0, ZERO = 0.D0
    real(dp), intent(in)      :: Coulomb_acc, TIMERATIO, FelTol, beta, mu
    real(dp), intent(in)      :: RX(Nr_atoms), RY(Nr_atoms), RZ(Nr_atoms), LBox(3)
    real(dp), intent(in)      :: Res(Nr_atoms)
    integer,    intent(in)      :: H_INDEX_START(Nr_atoms), H_INDEX_END(Nr_atoms)
    real(dp), intent(in)      :: Znuc(Nr_atoms), Hubbard_U(Nr_atoms)
    type(bml_matrix_t), intent(in)  :: HO_bml, S_bml, Z_bml, Inv_bml(m_rec), KK0_bml
    real(dp)                  :: K0Res(Nr_atoms)
    type(bml_matrix_t),intent(inout) :: H1_bml, X_bml,Y_bml,DO_bml,D1_bml
    real(dp), intent(in)      :: threshold
    integer,    intent(in)      :: LMAX
    character(10), intent(in)   :: Element_Type(Nr_atoms)
    integer,    intent(in)      :: nrnnlist(Nr_atoms), nnType(Nr_atoms,Max_Nr_Neigh)
    real(dp), intent(in)      :: nnRx(Nr_atoms,Max_Nr_Neigh)
    real(dp), intent(in)      :: nnRy(Nr_atoms,Max_Nr_Neigh), nnRz(Nr_atoms,Max_Nr_Neigh)
    real(dp)                  :: Coulomb_Pot_Real(Nr_atoms), Coulomb_Pot(Nr_atoms)
    real(dp)                  :: Coulomb_Pot_Real_I, Coulomb_Pot_k(Nr_atoms),dq_dv(Nr_atoms)
    real(dp)                  :: Coulomb_Pot_Real_dq_v(Nr_atoms), Coulomb_Pot_dq_v(Nr_atoms)
    real(dp)                  :: Coulomb_Force_Real_I(3),Coulomb_Force_k(3,Nr_atoms)
    real(dp)                  :: dq_v(Nr_atoms)
    real(dp), intent(inout)   :: KRes(Nr_atoms)
    integer                     :: I,J,K,It
    integer, intent(out)        :: L
    real(dp)                  :: Fel, proj_tmp
    real(dp)                  :: vi(Nr_atoms,LMAX), fi(Nr_atoms,LMAX), v(Nr_atoms)
    real(dp)                  :: dr(Nr_Atoms), IdentRes(Nr_atoms)
    real(dp), allocatable     :: O(:,:),M(:,:),row1(:),row2(:),row_NA(:)
    type(bml_matrix_t)          :: KK0T_bml, K0Res_bml, Res_bml

    allocate(row1(HDIM)); allocate(row2(HDIM)); allocate(row_NA(Nr_atoms))
    call bml_zero_matrix("ellpack",bml_element_real,dp,Nr_atoms,Nr_atoms,KK0T_bml)
    call bml_zero_matrix("ellpack",bml_element_real,dp,Nr_atoms,Nr_atoms,K0Res_bml)
    call bml_zero_matrix("ellpack",bml_element_real,dp,Nr_atoms,Nr_atoms,Res_bml)

    ! K0Res = KK0*Res temporary for matrix-vector multiplication
    call bml_transpose(KK0_bml,KK0T_bml)
    call bml_set_row(Res_bml,1,Res,ONE*1e-14)
    call bml_multiply(Res_bml,KK0T_bml,K0Res_bml,1.0_dp,0.0_dp,ONE*1e-14)
    call bml_get_row(K0Res_bml,1,row_NA)
    K0Res = row_NA
    dr = K0Res

    I = 0
    Fel = 1.D0
    do while ((Fel > FelTol).AND.(I < (LMAX)))   !! Fel = "Error" in Swedish
      I = I + 1
      vi(:,I) = dr/norm2(dr)
      do J = 1,I-1
        vi(:,I) = vi(:,I) - dot_product(vi(:,I),vi(:,J))*vi(:,J)  !! Orthogonalized v_i as in Eq. (42) Ref. [*]
      enddo
      vi(:,I) = vi(:,I)/norm2(vi(:,I))
      v(:) = vi(:,I)  ! v_i

      dq_v = v

      !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(J,Coulomb_Pot_Real_I,Coulomb_Force_Real_I)
      do J = 1,Nr_atoms
        call Ewald_Real_Space(Coulomb_Pot_Real_I,Coulomb_Force_Real_I,J,RX,RY,RZ,LBox, &
             dq_v,Hubbard_U,Element_Type,Nr_atoms,Coulomb_acc,TIMERATIO,nnRx,nnRy,nnRz,nrnnlist,nnType,HDIM,Max_Nr_Neigh)
        Coulomb_Pot_Real(J) = Coulomb_Pot_Real_I
      enddo
      !$OMP END PARALLEL DO

      ! call Ewald_k_Space(Coulomb_Pot_k,Coulomb_Force_k,RX,RY,RZ,LBox,dq_v,Nr_atoms,Coulomb_acc,TIMERATIO,Max_Nr_Neigh)
      ! Coulomb_Pot_dq_v = Coulomb_Pot_Real+Coulomb_Pot_k

      row1 = 0.0_dp
      do J = 1,HDIM
        call bml_set_row(H1_bml,J,row1,threshold)
      enddo

      !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(J,K)
      do J = 1,Nr_atoms
        do K = H_INDEX_START(J),H_INDEX_END(J)
          row1(K) = Hubbard_U(J)*dq_v(J) + Coulomb_Pot_dq_v(J)
        enddo
      enddo
      !$OMP END PARALLEL DO

      call bml_set_diagonal(H1_bml,row1,threshold)
      call bml_multiply(S_bml,H1_bml,D1_bml,1.0_dp,0.0_dp,threshold)
      call bml_multiply(H1_bml,S_bml,D1_bml,0.5_dp,0.5_dp,threshold)
      call bml_copy(D1_bml,H1_bml)

      call bml_transpose(Z_bml,X_bml)
      call bml_multiply(X_bml,H1_bml,D1_bml,1.0_dp,0.0_dp,threshold)
      call bml_multiply(D1_bml,Z_bml,H1_bml,1.0_dp,0.0_dp,threshold)

      call prg_implicit_fermi_first_order_response(HO_bml,H1_bml,DO_bml,D1_bml,Inv_bml, &
           m_rec, mu, beta, real(nocc,dp), threshold)

      call bml_transpose(Z_bml,X_bml)
      call bml_multiply(Z_bml,D1_bml,Y_bml,2.0_dp,0.0_dp,threshold)
      call bml_multiply(Y_bml,X_bml,D1_bml,1.0_dp,0.0_dp,threshold)

      !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(It,K,row1,row2)
      do It = 1, Nr_atoms
        dq_dv(It) = 0
        do K = H_INDEX_START(It), H_INDEX_END(It)
          call bml_get_row(S_bml,K,row1)
          call bml_get_row(D1_bml,K,row2)
          dq_dv(It) = dq_dv(It) + dot_product(row1,row2)
        enddo
      enddo
      !$OMP END PARALLEL DO

      dr = dq_dv - v
      ! fi = K0(dq_dv - v)
      call bml_set_row(Res_bml,1,dr,threshold)
      call bml_multiply(Res_bml,KK0T_bml,K0Res_bml,1.0_dp,0.0_dp,threshold)
      call bml_get_row(K0Res_bml,1,row_NA)
      dr = row_NA
      fi(:,I) = dr

      L = I
      allocate(O(L,L), M(L,L))
      do K = 1,L
        do J = 1,L
          O(K,J) = dot_product(fi(:,K),fi(:,J))  ! O_KJ = < fv_i(K) | fv_i(J) >  see below Eq. (31)
        enddo
      enddo
      call Invert(O,M,L)                        ! M = O^(-1)
      IdentRes = 0.D0*K0Res
      KRes = 0.D0
      do K = 1,L
        do J = 1,L
          proj_tmp = M(K,J)*dot_product(fi(:,J),K0Res)
          IdentRes = IdentRes + proj_tmp*fi(:,K)
          KRes = KRes + proj_tmp*vi(:,K)            !! KRes becomes the rank-L approximate of (K0*J)^(-1)*K0*(q[n]-n)
        enddo
      enddo
      Fel = norm2(IdentRes-K0Res)/norm2(IdentRes)  !! RELATIVE RESIDUAL ERROR ESTIMATE Eq. (48) Ref. [*]
      write(*,*) '# I, L, Fel = ',I,L,Fel         !! Fel goes down with L
      deallocate(O, M)

    enddo

    deallocate(row1);deallocate(row2);deallocate(row_NA)
    call bml_deallocate(KK0T_bml)
    call bml_deallocate(K0Res_bml)
    call bml_deallocate(Res_bml)

  end subroutine prg_kernel_multirank

  !> Compute full inverse Jacobian of q[n]-n (for LATTE)
  !! \param KK The inverse Jacobian.
  !! \param DO_bml Orthogonalized density matrix.
  !! \param mu0 The chemical potiential.
  !! \param RXYZ Nuclear coordinates.
  !! \param Box Box dimensions.
  !! \param Hubbard_U Hubbard U list.
  !! \param Element_Pointer List to keep track of elements.
  !! \param Nr_atoms The number of atoms.
  !! \param HDIM Hamiltonian matrix dimension.
  !! \param Max_Nr_Neigh Max neighbours for Ewald.
  !! \param Coulomb_acc Coulomb accuracy
  !! \param Hinxlist List to keep track of atomic positions in the Hamiltonian.
  !! \param S_bml The S matrix.
  !! \param Z_bml, The Z matrix.
  !! \param Inv_bml, Inverses generated by prg_implicit_fermi_save_inverse.
  !! \param HO_bml, Orthogonalized Hamiltonian matrix.
  !! \param D1_bml, H1_bml, Y_bml, X_bml Auxillary matrices.
  !! \param Nocc Occupation.
  !! \param m_rec Number of recursion steps.
  !! \param threshold Threshold value for matrix truncation.
  !! \param beta Scaled inverse temperature.
  !! \param Nr_elem Number of elements in Hubbard list.
  subroutine prg_full_kernel_latte(KK,DO_bml,mu0,RXYZ,Box,Hubbard_U, &
       Element_Pointer, Nr_atoms,HDIM, Max_Nr_Neigh,Coulomb_acc, &
       Hinxlist,S_bml,Z_bml,Inv_bml,D1_bml,H1_bml,HO_bml, &
       Nocc,m_rec,threshold,beta,Nr_elem,nebcoul,totnebcoul)

    use bml

    implicit none
    integer, parameter             :: PREC = 8, dp = kind(1.0d0)
    integer,    intent(in)         :: Nr_atoms, Nr_elem,HDIM, Max_Nr_Neigh,m_rec
    real(PREC), parameter          :: ONE = 1.D0, TWO = 2.D0, ZERO = 0.D0
    real(PREC), parameter          :: kB = 8.61739d-5 ! eV/K, kB = 6.33366256e-6 Ry/K, kB = 3.166811429e-6 Ha/K
    real(PREC), intent(in)         :: Coulomb_acc, threshold,beta,Nocc
    real(PREC)                     :: v(Nr_atoms)
    real(PREC), intent(in)         :: RXYZ(3,Nr_atoms),Box(3,3)
    integer,    intent(in)         :: Hinxlist(HDIM)
    real(PREC), intent(in)         :: Hubbard_U(Nr_elem)
    type(bml_matrix_t), intent(in)   :: Inv_bml(m_rec)
    type(bml_matrix_t), intent(in)   :: S_bml,Z_bml,HO_bml
    type(bml_matrix_t),intent(inout) :: H1_bml,DO_bml,D1_bml
    real(PREC), intent(inout)      :: mu0
    integer,    intent(in)         :: Element_Pointer(Nr_atoms),nebcoul(4,Max_Nr_Neigh,Nr_atoms),totnebcoul(Nr_atoms)
    real(PREC)                     :: Coulomb_Pot_Real(Nr_atoms), Coulomb_Pot(Nr_atoms)
    real(PREC)                     :: Coulomb_Pot_Real_I, Coulomb_Pot_k(Nr_atoms)
    real(PREC)                     :: Coulomb_Pot_Real_dq_v(Nr_atoms), Coulomb_Pot_dq_v(Nr_atoms)
    real(PREC)                     :: dq_v(Nr_atoms)
    real(PREC)                     :: dq_dv(Nr_atoms), err,tol,start,ewaldk,ewaldr,ewaldkacc,ewaldracc,response,respacc
    real(PREC), intent(out)        :: KK(Nr_atoms,Nr_atoms)
    integer                        :: I,J,K, ITER, mm,It,N,MN
    real(PREC),allocatable         :: row1(:),row2(:),JJ(:,:),E(:,:),EReal(:,:),EKspace(:,:)
    type(bml_matrix_t)             :: ZT_bml, R_bml, JJI_bml, JJ_bml, tmp_bml, X_bml, Y_bml
    character(20)                  :: bml_type

    bml_type = bml_get_type(HO_bml)
    N = bml_get_N(HO_bml)
    MN = bml_get_M(HO_bml)
    call bml_zero_matrix(bml_type,bml_element_real,dp,N,MN,ZT_bml)
    call bml_zero_matrix(bml_type,bml_element_real,dp,N,MN,X_bml)
    call bml_zero_matrix(bml_type,bml_element_real,dp,N,MN,Y_bml)
    call bml_transpose(Z_bml,ZT_bml)
    allocate(row1(HDIM)); allocate(row2(HDIM)); allocate(JJ(Nr_atoms,Nr_atoms))
    allocate(EReal(Nr_atoms,Nr_atoms)); allocate(EKspace(Nr_atoms,Nr_atoms))
    allocate(E(Nr_atoms,Nr_atoms))
    Coulomb_Pot_dq_v = ZERO
    Coulomb_Pot_k = ZERO
    dq_v = ZERO
    JJ = ZERO
    KK = ZERO

    !call Ewald_Real_Space_Matrix_latte(EReal,RXYZ,Box,Hubbard_U,Element_Pointer, &
    !        Nr_atoms,Coulomb_acc,Nebcoul,Totnebcoul,HDIM,Max_Nr_Neigh,Nr_Elem)
    !call Ewald_k_Space_Matrix_latte(EKspace,RXYZ,Box,Nr_atoms,Coulomb_acc,Max_Nr_Neigh,Nebcoul,Totnebcoul)
    !E = EReal + EKspace
    write(*,*) 'Beginning response calculations'
    ewaldracc = 0.0; ewaldkacc = 0.0; respacc = 0.0;
    do J = 1,Nr_atoms
      call cpu_time(start)
      write(*,*) 'J=',J
      dq_v(J) = ONE
      !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I,Coulomb_Pot_Real_I)
      do I = 1,Nr_atoms
        call Ewald_Real_Space_Single_latte(Coulomb_Pot_Real_I,I,RXYZ,Box,Nr_elem, &
             dq_v,J,Hubbard_U,Element_Pointer,Nr_atoms,Coulomb_acc,HDIM,Max_Nr_Neigh)
        Coulomb_Pot_Real(I) = Coulomb_Pot_Real_I
      enddo
      !$OMP END PARALLEL DO
      call cpu_time(ewaldr)
      ewaldracc = ewaldracc + ewaldr-start
      call Ewald_k_Space_latte_single(Coulomb_Pot_k,J,RXYZ,Box,dq_v,Nr_atoms,Coulomb_acc)
      Coulomb_Pot_dq_v = Coulomb_Pot_Real+Coulomb_Pot_k
      call cpu_time(ewaldk)
      ewaldkacc = ewaldkacc + ewaldk-ewaldr


      call bml_deallocate(H1_bml)
      call bml_zero_matrix(bml_type,bml_element_real,dp,N,MN,H1_bml)

      !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I,K)
      do I = 1,Nr_atoms-1
        do K = Hinxlist(I)+1,Hinxlist(I+1)
          row1(K) = Hubbard_U(Element_Pointer(I))*dq_v(I) + Coulomb_Pot_dq_v(I)
        enddo
      enddo
      !$OMP END PARALLEL DO
      do K = Hinxlist(Nr_atoms)+1,HDIM
        row1(K) = Hubbard_U(Element_Pointer(Nr_atoms))*dq_v(Nr_atoms) + Coulomb_Pot_dq_v(Nr_atoms)
      enddo

      call bml_set_diagonal(H1_bml,row1,threshold)
      call bml_multiply(S_bml,H1_bml,X_bml,1.0_dp,0.0_dp,threshold)
      call bml_multiply(H1_bml,S_bml,X_bml,0.5_dp,0.5_dp,threshold)
      call bml_copy(X_bml,H1_bml)

      call bml_multiply(ZT_bml,H1_bml,X_bml,1.0_dp,0.0_dp,threshold)
      call bml_multiply(X_bml,Z_bml,H1_bml,1.0_dp,0.0_dp,threshold)

      call prg_implicit_fermi_first_order_response(HO_bml,H1_bml,DO_bml,D1_bml,Inv_bml, &
           m_rec,mu0,beta,Nocc,threshold)
      call cpu_time(response)
      respacc = respacc + response-ewaldk

      call bml_multiply(Z_bml,D1_bml,Y_bml,2.0_dp,0.0_dp,threshold)
      call bml_multiply(Y_bml,ZT_bml,D1_bml,1.0_dp,0.0_dp,threshold)

      call bml_multiply(D1_bml,S_bml,X_bml,1.0_dp,0.0_dp,threshold)
      call bml_get_diagonal(X_bml,row1)
      !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(It,K)
      do It = 1, Nr_atoms-1
        dq_dv(It) = 0
        do K = Hinxlist(It)+1,Hinxlist(It+1)
          dq_dv(It) = dq_dv(It) + row1(K)
        enddo
        JJ(It,J) = dq_dv(It)
      enddo
      !$OMP END PARALLEL DO
      dq_dv(Nr_atoms) = 0
      do K = Hinxlist(Nr_atoms)+1,HDIM
        dq_dv(Nr_atoms) = dq_dv(Nr_atoms) + row1(K)
      enddo
      JJ(Nr_atoms,J) = dq_dv(Nr_atoms)
      dq_v = ZERO
    enddo

    do I = 1,Nr_atoms
      JJ(I,I) = JJ(I,I) - ONE
    enddo

    write(*,*) 'ewaldracc =', ewaldracc
    write(*,*) 'ewaldkacc =', ewaldkacc
    write(*,*) 'implcit response time =', respacc
    call Invert(JJ,KK,Nr_atoms)

    deallocate(row1); deallocate(row2); deallocate(JJ)
    deallocate(E); deallocate(EReal); deallocate(EKspace)
    call bml_deallocate(ZT_bml)
    call bml_deallocate(X_bml)
    call bml_deallocate(Y_bml)

  end subroutine prg_full_kernel_latte

  !> Compute full inverse Jacobian of q[n]-n (for development code)
  !! \param KK The inverse Jacobian.
  !! \param DO_bml Orthogonalized density matrix.
  !! \param mu0 The chemical potiential.
  !! \param RX,RY,RZ Nuclear coordinates.
  !! \param Lbox Box dimensions.
  !! \param Hubbard_U Hubbard U list.
  !! \param Element_Type List to keep track of elements.
  !! \param Nr_atoms The number of atoms.
  !! \param HDIM Hamiltonian matrix dimension.
  !! \param Max_Nr_Neigh Max neighbours for Ewald.
  !! \param Coulomb_acc Coulomb accuracy
  !! \param TIMERATIO Parameter for Ewald
  !! \param nnRx,nnRy,nnRz Neighbour lists.
  !! \param nrnnlist Number of neighbours list.
  !! \param nnType Refers to original order of atoms.
  !! \param H_INDEX_START, H_INDEX_END Lists to keep track of atomic positions in the Hamiltonian.
  !! \param S_bml The S matrix.
  !! \param Z_bml, The Z matrix.
  !! \param Inv_bml, Inverses generated by prg_implicit_fermi_save_inverse.
  !! \param HO_bml, Orthogonalized Hamiltonian matrix.
  !! \param D1_bml, H1_bml, Y_bml, X_bml Auxillary matrices.
  !! \param Nocc Occupation.
  !! \param Znuc List of nuclear charges.
  !! \param m_rec Number of recursion steps.
  !! \param threshold Threshold value for matrix truncation.
  !! \param beta Scaled inverse temperature.
  !! \param diagonal Auxillary vector.

  subroutine prg_full_kernel(KK,DO_bml,mu0,RX,RY,RZ,LBox,Hubbard_U,Element_Type, &
       Nr_atoms,HDIM, Max_Nr_Neigh,Coulomb_acc,TIMERATIO,nnRx,nnRy,nnRz, &
       nrnnlist,nnType,H_INDEX_START,H_INDEX_END,S_bml,Z_bml,Inv_bml,D1_bml,H1_bml,HO_bml,Y_bml,X_bml, &
       Nocc,Znuc,m_rec,threshold,beta,diagonal)

    use bml

    implicit none
    integer, parameter             :: PREC = 8, dp = kind(1.0d0)
    integer,    intent(in)         :: Nr_atoms, HDIM, Nocc, Max_Nr_Neigh,m_rec
    real(PREC), parameter          :: ONE = 1.D0, TWO = 2.D0, ZERO = 0.D0
    real(PREC), parameter          :: kB = 8.61739d-5 ! eV/K, kB = 6.33366256e-6 Ry/K, kB = 3.166811429e-6 Ha/K
    real(PREC), intent(in)         :: Coulomb_acc, TIMERATIO,threshold,beta
    real(PREC)                     :: v(Nr_atoms)
    real(PREC), intent(in)         :: RX(Nr_atoms), RY(Nr_atoms), RZ(Nr_atoms), LBox(3)
    integer,    intent(in)         :: H_INDEX_START(Nr_atoms), H_INDEX_END(Nr_atoms)
    real(PREC), intent(in)         :: Znuc(Nr_atoms), Hubbard_U(Nr_atoms)
    type(bml_matrix_t), intent(in)   :: Inv_bml(m_rec)
    type(bml_matrix_t), intent(in)   :: S_bml,Z_bml,HO_bml
    type(bml_matrix_t),intent(inout) :: H1_bml,DO_bml,D1_bml,Y_bml,X_bml
    real(PREC), intent(inout)      :: mu0, diagonal(HDIM)
    character(10), intent(in)      :: Element_Type(Nr_atoms)
    integer,    intent(in)         :: nrnnlist(Nr_atoms), nnType(Nr_atoms,Max_Nr_Neigh)
    real(PREC), intent(in)         :: nnRx(Nr_atoms,Max_Nr_Neigh)
    real(PREC), intent(in)         :: nnRy(Nr_atoms,Max_Nr_Neigh), nnRz(Nr_atoms,Max_Nr_Neigh)
    real(PREC)                     :: Coulomb_Pot_Real(Nr_atoms), Coulomb_Pot(Nr_atoms)
    real(PREC)                     :: Coulomb_Pot_Real_I, Coulomb_Pot_k(Nr_atoms)
    real(PREC)                     :: Coulomb_Pot_Real_dq_v(Nr_atoms), Coulomb_Pot_dq_v(Nr_atoms)
    real(PREC)                     :: Coulomb_Force_Real_I(3),Coulomb_Force_k(3,Nr_atoms)
    real(PREC)                     :: dq_v(Nr_atoms)
    real(PREC)                     :: dq_dv(Nr_atoms)
    real(PREC), intent(out)        :: KK(Nr_atoms,Nr_atoms)
    integer                        :: I,J,K, ITER, mm,It
    real(PREC),allocatable         :: row1(:),row2(:),JJ(:,:)

    allocate(row1(HDIM)); allocate(row2(HDIM)); allocate(JJ(Nr_atoms,Nr_atoms))
    Coulomb_Pot_dq_v = ZERO
    Coulomb_Pot_k = ZERO
    dq_v = ZERO
    JJ = ZERO
    KK = ZERO

    do J = 1,Nr_atoms
      dq_v(J) = ONE
      !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I,Coulomb_Pot_Real_I)
      do I = 1,Nr_atoms
        call Ewald_Real_Space_Single(Coulomb_Pot_Real_I,Coulomb_Force_Real_I,I,RX,RY,RZ,LBox, &
             dq_v,J,Hubbard_U,Element_Type,Nr_atoms,Coulomb_acc,TIMERATIO,HDIM,Max_Nr_Neigh)
        Coulomb_Pot_Real(I) = Coulomb_Pot_Real_I
      enddo
      !$OMP END PARALLEL DO
      !  call Ewald_k_Space(Coulomb_Pot_k,Coulomb_Force_k,RX,RY,RZ,LBox,dq_v,Nr_atoms,Coulomb_acc, &
      !       TIMERATIO,Max_Nr_Neigh)
      Coulomb_Pot_dq_v = Coulomb_Pot_Real+Coulomb_Pot_k

      diagonal = 0.0_dp
      do I = 1,HDIM
        call bml_set_row(H1_bml,I,diagonal,threshold)
      enddo

      !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I,K)
      do I = 1,Nr_atoms
        do K = H_INDEX_START(I),H_INDEX_END(I)
          diagonal(K) = Hubbard_U(I)*dq_v(I) + Coulomb_Pot_dq_v(I)
        enddo
      enddo
      !$OMP END PARALLEL DO

      call bml_set_diagonal(H1_bml,diagonal,threshold)
      call bml_multiply(S_bml,H1_bml,D1_bml,1.0_dp,0.0_dp,threshold)
      call bml_multiply(H1_bml,S_bml,D1_bml,0.5_dp,0.5_dp,threshold)
      call bml_copy(D1_bml,H1_bml)

      call bml_transpose(Z_bml,X_bml)
      call bml_multiply(X_bml,H1_bml,D1_bml,1.0_dp,0.0_dp,threshold)
      call bml_multiply(D1_bml,Z_bml,H1_bml,1.0_dp,0.0_dp,threshold)

      call prg_implicit_fermi_first_order_response(HO_bml,H1_bml,DO_bml,D1_bml,Inv_bml, &
           m_rec,mu0,beta,real(nocc,PREC),threshold)

      call bml_transpose(Z_bml,X_bml)
      call bml_multiply(Z_bml,D1_bml,Y_bml,2.0_dp,0.0_dp,threshold)
      call bml_multiply(Y_bml,X_bml,D1_bml,1.0_dp,0.0_dp,threshold)

      do It = 1, Nr_atoms
        dq_dv(It) = 0
        do K = H_INDEX_START(It), H_INDEX_END(It)
          call bml_get_row(S_bml,K,row1)
          call bml_get_row(D1_bml,K,row2)
          dq_dv(It) = dq_dv(It) + dot_product(row1,row2)
        enddo
        JJ(It,J) = dq_dv(It)
      enddo
      dq_v = ZERO
    enddo

    do I = 1,Nr_atoms
      JJ(I,I) = JJ(I,I) - ONE
    enddo
    call Invert(JJ,KK,Nr_atoms)
    deallocate(row1); deallocate(row2); deallocate(JJ)

  end subroutine prg_full_kernel


  ! Compute the low-rank kernel matrix. (For development code)
  subroutine prg_kernel_matrix_multirank(KRes,KK0_bml,Res,FelTol,L,LMAX,HO_bml,mu,beta,RX,RY,RZ,LBox,Hubbard_U,Element_Type, &
       Nr_atoms,HDIM,Max_Nr_Neigh,Coulomb_acc,TIMERATIO,nnRx,nnRy,nnRz,nrnnlist,nnType,H_INDEX_START,H_INDEX_END, &
       S_bml,Z_bml,Nocc,Znuc,Inv_bml,H1_bml,X_bml,Y_bml,DO_bml,D1_bml,m_rec,threshold)

    !! Res = q[n] - n
    !! KK0 is preconditioner
    !! KRes rank-L approximation of (K0*J)^(-1)*K0*(q[n]-n) with (K0*J)^(-1) as in Eq. (41) in Ref. [*]

    implicit none
    integer,    intent(in)      :: Nr_atoms, HDIM, Max_Nr_Neigh,m_rec
    real(dp), parameter       :: ONE = 1.D0, TWO = 2.D0, ZERO = 0.D0
    real(dp), intent(in)      :: Coulomb_acc, TIMERATIO, FelTol, beta, mu,Nocc
    real(dp), intent(in)      :: RX(Nr_atoms), RY(Nr_atoms), RZ(Nr_atoms), LBox(3)
    real(dp), intent(in)      :: Res(Nr_atoms)
    integer,    intent(in)      :: H_INDEX_START(Nr_atoms), H_INDEX_END(Nr_atoms)
    real(dp), intent(in)      :: Znuc(Nr_atoms), Hubbard_U(Nr_atoms)
    type(bml_matrix_t), intent(in)  :: HO_bml, S_bml, Z_bml, Inv_bml(m_rec)
    real(dp)                  :: K0Res(Nr_atoms)
    type(bml_matrix_t),intent(inout) :: H1_bml, X_bml,Y_bml,DO_bml,D1_bml
    type(bml_matrix_t),intent(inout) :: KK0_bml
    real(dp), intent(in)      :: threshold
    integer,    intent(in)      :: LMAX
    character(10), intent(in)   :: Element_Type(Nr_atoms)
    integer,    intent(in)      :: nrnnlist(Nr_atoms), nnType(Nr_atoms,Max_Nr_Neigh)
    real(dp), intent(in)      :: nnRx(Nr_atoms,Max_Nr_Neigh)
    real(dp), intent(in)      :: nnRy(Nr_atoms,Max_Nr_Neigh), nnRz(Nr_atoms,Max_Nr_Neigh)
    real(dp)                  :: Coulomb_Pot_Real(Nr_atoms), Coulomb_Pot(Nr_atoms)
    real(dp)                  :: Coulomb_Pot_Real_I, Coulomb_Pot_k(Nr_atoms),dq_dv(Nr_atoms)
    real(dp)                  :: Coulomb_Pot_Real_dq_v(Nr_atoms), Coulomb_Pot_dq_v(Nr_atoms)
    real(dp)                  :: Coulomb_Force_Real_I(3),Coulomb_Force_k(3,Nr_atoms)
    real(dp)                  :: dq_v(Nr_atoms)
    real(dp), intent(out)     :: KRes(Nr_atoms)
    integer                     :: I,J,K,It,col,row
    integer, intent(out)        :: L
    real(dp)                  :: Fel, proj_tmp,elem
    real(dp)                  :: vi(Nr_atoms,LMAX), fi(Nr_atoms,LMAX), v(Nr_atoms)
    real(dp)                  :: dr(Nr_Atoms), IdentRes(Nr_atoms)
    real(dp), allocatable     :: O(:,:),M(:,:),row1(:),row2(:)

    allocate(row1(HDIM));allocate(row2(HDIM));

    dr = Res
    I = 0
    Fel = 1.D0
    do while ((Fel > FelTol).AND.(I < (LMAX)))   !! Fel = "Error" in Swedish
      I = I + 1
      vi(:,I) = dr/norm2(dr)
      do J = 1,I-1
        vi(:,I) = vi(:,I) - dot_product(vi(:,I),vi(:,J))*vi(:,J)  !! Orthogonalized v_i as in Eq. (42) Ref. [*]
      enddo
      vi(:,I) = vi(:,I)/norm2(vi(:,I))
      v(:) = vi(:,I)  ! v_i

      dq_v = v

      !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(I,Coulomb_Pot_Real_I,Coulomb_Force_Real_I)
      do J = 1,Nr_atoms
        call Ewald_Real_Space(Coulomb_Pot_Real_I,Coulomb_Force_Real_I,J,RX,RY,RZ,LBox, &
             dq_v,Hubbard_U,Element_Type,Nr_atoms,Coulomb_acc,TIMERATIO,nnRx,nnRy,nnRz,nrnnlist,nnType,HDIM,Max_Nr_Neigh)
        Coulomb_Pot_Real(J) = Coulomb_Pot_Real_I
      enddo
      !$OMP END PARALLEL DO

      ! call Ewald_k_Space(Coulomb_Pot_k,Coulomb_Force_k,RX,RY,RZ,LBox,dq_v,Nr_atoms,Coulomb_acc,TIMERATIO,Max_Nr_Neigh)
      ! Coulomb_Pot_dq_v = Coulomb_Pot_Real+Coulomb_Pot_k

      row1 = 0.0_dp
      do J = 1,HDIM
        call bml_set_row(H1_bml,J,row1,threshold)
      enddo

      !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(J,K)
      do J = 1,Nr_atoms
        do K = H_INDEX_START(J),H_INDEX_END(J)
          row1(K) = Hubbard_U(J)*dq_v(J) + Coulomb_Pot_dq_v(J)
        enddo
      enddo
      !$OMP END PARALLEL DO

      call bml_set_diagonal(H1_bml,row1,threshold)
      call bml_multiply(S_bml,H1_bml,D1_bml,1.0_dp,0.0_dp,threshold)
      call bml_multiply(H1_bml,S_bml,D1_bml,0.5_dp,0.5_dp,threshold)
      call bml_copy(D1_bml,H1_bml)

      call bml_transpose(Z_bml,X_bml)
      call bml_multiply(X_bml,H1_bml,D1_bml,1.0_dp,0.0_dp,threshold)
      call bml_multiply(D1_bml,Z_bml,H1_bml,1.0_dp,0.0_dp,threshold)

      call prg_implicit_fermi_first_order_response(HO_bml,H1_bml,DO_bml,D1_bml,Inv_bml, &
           m_rec, mu, beta, Nocc, threshold)

      call bml_transpose(Z_bml,X_bml)
      call bml_multiply(Z_bml,D1_bml,Y_bml,2.0_dp,0.0_dp,threshold)
      call bml_multiply(Y_bml,X_bml,D1_bml,1.0_dp,0.0_dp,threshold)

      !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(It,K,row1,row2)
      do It = 1, Nr_atoms
        dq_dv(It) = 0
        do K = H_INDEX_START(It), H_INDEX_END(It)
          call bml_get_row(S_bml,K,row1)
          call bml_get_row(D1_bml,K,row2)
          dq_dv(It) = dq_dv(It) + dot_product(row1,row2)
        enddo
      enddo
      !$OMP END PARALLEL DO

      dr = dq_dv - v
      fi(:,I) = dr

      L = I
      allocate(O(L,L), M(L,L))
      do K = 1,L
        do J = 1,L
          O(K,J) = dot_product(fi(:,K),fi(:,J))  ! O_KJ = < fv_i(K) | fv_i(J) >  see below Eq. (31)
        enddo
      enddo
      call Invert(O,M,L)                        ! M = O^(-1)
      IdentRes = 0.D0*Res
      KRes = 0.D0
      do K = 1,L
        do J = 1,L
          proj_tmp = M(K,J)*dot_product(fi(:,J),Res)
          IdentRes = IdentRes + proj_tmp*fi(:,K)
          KRes = KRes + proj_tmp*vi(:,K)            !! KRes becomes the rank-L approximate of (J)^(-1)*(q[n]-n)
        enddo
      enddo
      Fel = norm2(IdentRes-Res)/norm2(IdentRes)  !! RELATIVE RESIDUAL ERROR ESTIMATE Eq. (48) Ref. [*]
      write(*,*) '# I, L, Fel = ',I,L,Fel         !! Fel goes down with L

      ! Does not work, need to normalize matrix
      if ((Fel > FelTol).AND.(I < (LMAX))) then
        deallocate(O, M)
      else
        do row = 1,Nr_atoms
          do col = 1,Nr_atoms
            elem = 0.0
            do K = 1,L
              do J = 1,L
                elem = elem + M(J,K)*vi(row,J)*fi(col,K)
              enddo
            enddo
            if (abs(elem) > threshold) then
              call bml_set_element(KK0_bml,row,col,elem)
            endif
          enddo
        enddo
        deallocate(O,M)
      endif
    enddo
    deallocate(row1); deallocate(row2);

  end subroutine prg_kernel_matrix_multirank

end module prg_xlbokernel_mod
